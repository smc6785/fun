- lazy:
  - copy-on-write
  - writing buffering
  - zero-filled in demand
  - demand paging
  - memory mapped files

- if a process needs more memory to fit exec(), it could use malloc() and sbrk()
- every process has its own unique fd

OS purposes:
- abstract hardware for convenience and portability
- multiplex the hardware among many applications
- isolation applications in order to contain bugs
- allow sharing among coopeerating applications
- control sharing for security
- dont get in the way og high performance
- support a wide range of applications

OS orgnization:
 user:VI,CC:C compilor,SH:shell
 kernel:FS:file system, processes,memory allocation, access control
CPU
RAM 
DISK
NET

API-kernel(system call)
- open file:
  fileDescriptor = open("fileName",1)
  fileDescriptor,fd, so the system uses it as a handle to refer to this open file
- write file:
  write(fd,"hello\n",6)
  a pointor to a buffer of characters "hello\n"
- fork is the system call that create a new process:
  pid = fork();
  pid, process indentifier

efficient-abstract
powerful-simple API
flexible-secure

system calls are the interface to the services that the OS provides

OS xv6
microprocessor RICS-V
QEMU machine simtlator

xv6 has no ps command, but, if you type Ctrl-p, the kernel will print information about each process. If you try it now, you'll see two lines: one for init, and one for sh.

To quit qemu type: Ctrl-a x (press Ctrl and a at the same time, followed by x).

---
- C uses manual memory mangagement, not garbage collection
  - explicit malloc() and free(); direct access to memory

- endianness
  - 0x12345678
  - big-endian, 0x12, 0x34, 0x56, 0x78
  - small-endian, 0x78, 0x56, 0x34, 0x12
  - big-endian means it starts with the most significant byte
  - little-endian means it starts with the least significant byte

memory in C 
-Static memory
  - global variables
      variables declared outsided any functiion, and variablees declared with static
  - a signggle is stored, at a predefined and unchanging memory address
  - initialized to zero by default
-stack memory
  - local variables within functions. Destroyed after function exits
  - not initialized by default. will refleect whatever happened to be in that piece of memory
-Heap memory
  - users can control creation and destruction of these variables:
malloc() free()
      this can lead to memory leaks, use-after-free issues
  - not initialized by default. will refleect whatever happened to be in that piece of memory
---
pointers in C
a pointer is a 640bit integer whose value is an address in memory
every variable has an address. so every variable's pointer can be accessed
including a pointer to a pointer, and a pointeer to a pointer to a pointer...
a pointer can handle arithmetic with the operators ++,--,-,+

int x =5;
int* x_address = &x;
* x_adddress = 6; // use * operator to access the uderlying value
int x_value = * x_address; // this gives 6
int arr1[10]; // arrays are secretly pointers
int* arr2[20]; // array of pointers, making arr2 a pointer to a piointer
void* myPtr;
---
arrays in C
C arrays are contiguous blocks of memory holding a particular data type
the variable is the pointer to the beginning of the array

char myString[40]; // type of myString is char*
char* myArrayOfStrings[20]; // type of myArrayOfStrings is char**
int counting[5] ={1,2,3,4,5}; //type of counting is int*

int arr[4]={5,6,7,8};
these are all equivalent
arr[2]=50;
*(arr+2)=50;
2[arr]=50;
downsides:
users are allowed to access or modify illegal memory by accessing an array out of bounds. C provides no checking whatsoever.

int strlen(const char& str){
  int i;
  for(i =0;str[i] !=0li++){
    return i;
  }
}

===
* unix interface
  - abstracts thee hardware resources
    - OS offers processes instead of CPU
    - OS offers exec() instead of memory
    - OS offers files instead of disk block
  - hardware supports for isolation
    - user/kernel mode
      - kernel, privileged instructions
        - set up page table, disabling clock, interrypts
      - user, unprivileged instructions, add, sub, branch, jr
    - virutal memory
      - page table, virtual addresses -> physical addresses
        - each process has its own page table, 
            - so it can only access to that physcial memory
            - memory isolation
  - entrying kernel
    - in xv6, ecall(n), n is the system call number
      - write(), in user space -> ecall -> sys_wrtite -> syscall in the kernel -> write 

* kernel, trusted computing base, TCB
  - kernel must have no bugs
  - kernel must treat processes as malicious
  - monolithic design
    - huge codes, more bugs
    - tight integrition, better performance
  - microkernel design
    - small, fewer bugs
    - less performance
    - consists of IPC, inter-process communication (message passing), VM, and mulitplexing for CPUs

  - pro.c ->gcc-> proc.s (RISC-V) ->assembler-> proc.o
    - take all .o link(ld) to kernel
    - kernel.asm
  - qemu
    - for(;;){
        read instruction
        decode instruction
        execute instruction
      } 
    - registers

page tables, virtual memory
- address spaces
- hardware for page table
  - memory management unit
    - read the mapping from memory and do the translate
    -       virtual address | physical adddress
            0xx1000         | 0x12345678
    - CPU -> virtual address -> MMU -> physical address -> memory
  - satp register in CPU tells where is the memory map in memory
    - when CPU switches between processes, it also switch satp register
  - every application has their own map
- 64 bit wide register, 2^64 possible address
  - per address X, too many
  - per page, 4KB, 4096 bytes
    - virtual address, 64
      - 25  | 27    | 12
        EXT | index |offset
      - supports 2^39 = 512 Gbyte used in RISC-V virtual memory
      - index used for page table
        - MMU takes index to the map and finds physical page number (PPN) in memory
        - PPN points to a 4KB (2^12 = 4096bits) page, offset indexs the page
    - physical address, 56
      - 44                        | 12      
        PPN, physical page number | offset  
      - supports 2^56 bits of physical memory
- page table structure
  - in RISC-V, there are 2^27 entries for the page table
    - 9 | 9 | 9 | 12
      L2|L1 | L0| offset
- translation look-aside buffer, TLB in the CPU
  - stores when doing page table loop up
  - cache of PTE 
  - [virtual address, physical aadress]
  - switch page -> flush TLB
- physical address
  - DRAM
  - i/o devices 0x0 -> 0x80000000

ISA, instruction set architecture
RICS-V, reduced instruction set 
x86-64, CISC, complex instruction set
ARM, RISC

* traps
- a trap is a synchronous interrupt triggered by an exception in a user process to execute functionality
- RISC-V CPU has:
  - 32 registers, including stack pointer register
  - program counter register
  - MODE
  - SATP, pointer to the page table
  - STVEC,
  - SEPC
  - SSCRATCH

- supervisor mode
  - R/W control register
  - use PTEs with PTE_U 

- Shell
  wrtie()
  ecall
  uservec -trampline       userset()
  usertrap()
  syscall()         usertrapret()
  sys_wrtie()

===
* KVM
- kernel-based vitrual machine

linux file structure
*bin
*sbin, system bin
*boot, bootloader
*dev, devices
*etc, configration file
*lib, library, required by bin
*opt, optional
*usr, unix system resource
https://www.pathname.com/fhs/pub/fhs-2.3.pdf

===
AoC 2021 in TempleOS 
https://www.youtube.com/watch?v=nvldfkikveI&ab_channel=TsodingDaily

ls -l -h, use -h option together with -l, this will have the pitput in k,M,G for a better understanding

.../qemu-system-x86_64 -cdrom .../TempleOS.ISO
* x86_64 is a 64 bit version of the x86 instriuction set
* x86 is a family of instuction set architecture initially developed by Intel based on Intel 8086 microprocessor and its 8088 variant
* cdrom, compact disc read only memory

.../qemu-system-x86_64 --help | more
* more is old utility
* less is more + more additional features

.../qemu-system-x86_64 -cdrom .../TempleOS.ISO -m 512
* if qemu-system-x86_64 is not able to read the bios.bin under /usr/share/qemu directory, then it will end up with an error Çould not load PC bios.bin
* ‘-L /usr/local/Cellar/qemu/6.1.0_1/share/qemu‘ and this will allow the command qemu-system-x86_64 to look out for the bios.bin under the given directory.

 /Users/chenshen/Downloads/qemu/build/qemu-system-x86_64 -cdrom /Users/chenshen/Downloads/TempleOS.ISO  -m 512 -L /usr/local/Cellar/qemu/6.1.0_1/share/qemu
* when OS doesnt have GUI, use ctrl-a x to quit

 /Users/chenshen/Downloads/qemu/build/qemu-system-x86_64 -cdrom /Users/chenshen/Downloads/TempleOS.ISO  -m 512 -L /usr/local/Cellar/qemu/6.1.0_1/share/qemu -enable-kvm
* kvm, kernel-based virtual machine. This acceleration method won't work, kvm is the linux hypervisor implementation
* use accel=hvf instead

creat a hardrive for templeOS
/Users/chenshen/Downloads/qemu/build/qemu-img --help | more
/Users/chenshen/Downloads/qemu/build/qemu-img create templeOS.img 512M

 /Users/chenshen/Downloads/qemu/build/qemu-system-x86_64 -cdrom /Users/chenshen/Downloads/TempleOS.ISO  -m 512 -L /usr/local/Cellar/qemu/6.1.0_1/share/qemu -hda ./templeOS.img

boot from the image
/Users/chenshen/Downloads/qemu/build/qemu-system-x86_64 -m 512 -L /usr/local/Cellar/qemu/6.1.0_1/share/qemu -hda ./templeOS.img

#!/bin/sh, bourne shell compatible script
The first line tells the shell that if you execute the script directly (./run.sh; as opposed to /bin/sh run.sh), it should use that program (/bin/sh in this case) to interpret it.
If the file that this script lives in is executable, the hash-bang (#!) tells the operating system what interpreter to use to run the script. In this case it's /bin/sh, for example.

set -x, in shell script

print shell co,,amd nefore execute it

set -e, in shell script

if the return code of one command is not 0 and the caller doesnt check it, the shell script will exit.

chmod, changes the file mode bits of each given file according to mode
chmod +x on a file/ script, means you'll make it executable
* if its not executable, use sh run.sh to run it

next line, ctrl v + ctrl j

linux, mounting and unmounting a filesystem
- to begin interacting with the disk, we need to mount the filesystem to  a directory.
* why not just cd /dev/sdb (second disk), becuse /dev/sdb is not a directory
* to resolve this, we need to create a directory and then mount the file system of the external drive to this directory
* most OS actually do this for us automatically when we plug ina device like a USB drive.
* unmount the filesystem, using umount

example:
	sudo parted -l
	sudo mount /dev/sdb1 .../myUsb
	cd .../myUsb
	sudo umount /dev/sdb1 or sudo umount .../myUsb

permanently mount a disk
automatically load up when the computer boots, to do this, we need to modify /etc/fstab 
fstab contains a list of unique device IDs, their mount points, types of file system and so on
* blkid, for the storaghe block device IDs

how to run qemu:
1. setup a virtual disk
	- qemu-img create image.img 200M
	- it will create an image file thats about 200MB
2. run qemu
	- to emulate a legacy PC system, use qemu-system-i386
	- to emulate a more modern system, use qemu-system-x86_64
	- use -hda imagefile to tell qemu to use imagefile as the hard drive image, this should be the same virtual disk you defined with the qemu-img command
	- set -cdrom isofile to define the CD_ROM or DVD image file.
3. memory
	= set the amount of memory in the virtual machine with the -m size option
	- default 128MB
4. boot order
	- use -boot [options] to specify the order that qemu should look for bootable devices
	- for example, set -boot order=dc to tell QEMU to try the CDROM (d) first, then the hard drive (c)

hot to mount a QEMU virtual disk image:
- linux can mount QEMU's raw disk image format, assuming it knows where to find the start of the C drive partition on the virtual disk. a virtual disk can contain multiple paritions
- use linux fdisk program, with -l option will list the partitions on the virtual disk
		fdisk -l image.img
    output: 
						Disk image.img: 100 MiB, 104857600 bytes, 204800 sectors
						Units: sectors of 1 * 512 = 512 bytes
						Sector size (logical/physical): 512 bytes / 512 bytes
						I/O size (minimum/optimal): 512 bytes / 512 bytes
						Disklabel type: dos
						Disk identifier: 0x00000000

						Device     Boot Start    End Sectors  Size Id Type
						image.img1 *       63 204623  204561 99.9M  6 FAT16
		here the C drive is the first and only partition on the virtual drive, listed as image.img1.
		to determine the offset of the C drive, you need to know the starting sector of that partition. the ouput from fdisk shows this as 63
		to calcualte the offset, you also need to know the sector size. This virtual disk image has sectors of 512 bytes. 
		you can calculate the offset as the product oif the offset and the sector size: 63* 512 = 32256
- use this offset value to mount the virtual C drive from linux
	mkdir /temp/dos
	sudo mount -o loop, offset =32256 image.img /temp/dos
	ls /tmp/dos
	sudo umount /temp/dos
	* /tmp/dos is a temporary directory for DOS system


the main components of OS are
- kernel
  kernel is responsible for managing the communication between the softwaare, user level applications and the hardware, CPU, disk memory etc.
- process management
- file system
- memory management
- I/O management

two important region of a memory
- user space
  it is a region of memeory where normal user processes run, everything other than kernel
- kernel space
  it is a region of memory where code of kernel resides and executes.
  it is considered to be privileged part of a memeory invoked by system calls, it is also known as system space
 
 a program is a passive entity residing at secondray memory
 a process is an active entity resding in the main memory

 a process can go through following states in its lifecycle
 - new
 - ready
 - running
 - waiting
 - terrminated

pid, process id

fork() is a system call which is responsible for creating a copy of a current process
the current process is termed as parent process and the created process is termed as child process
- fork creates a copy of the memory of instructions and data of the calling process
- it returns in both process, in the original process, it returns the process id of the newly created process. in the newe process, it returns 0
- fd table is copied, parents have some file open, child sees the same

system call
its like a way by which any user level program ask for the services offered by a kernel
it acts as an interface between a process and the OS

PCB, process control block
a data structure which hold all information, attributes of a process

there are four section of a process
- stack, contains local variables, returns address
- heap, dynamically allocated memory via malloc, calloc, realloc
- data, contains global and static vaiables
- code or text, contains code, program counter and content of processor's register

malloc()
memory allocation
it reserves a block of memory of the specified number of bytes
it returns a pointer of void which can be casted into pointers of any form

calloc()
contiguous allocation
malloc() function allocates memory and leaves the memory uninitialized
calloc() function allocates memory and initializes all bits to zero

realloc()
if the dynamically allocated memory is insufficinet or more than required,
you can change the size of previously allocated memory using the realloc()
e.g ptr = realloc(ptr,x);
ptr is reallocated with a new size x

context switching
it is switching of a processor from one process/thread to antoehr

inode
it is a data structure which holds all the attributes of a file
like file type, permission, file size, time when last it is modified

thread
thread is a concurrent unit of execution within a process
a process can have multiple threads where each thread can perform a different task independently, thus increasing the efficiency of a process.
a process always has one thread by default called main thread which is executed first
e.g 
- Word processor, a background thread may check spelling and grammar while a foreground thread processes user input (keystrokes).
- Web server – Multiple threads allow for multiple requests to be served simultaneously, without having to service requests sequentially.

benifits of a thread
- responsiveness
  a process with thread are said to be more responsiveness than a process without thread 
  because even if one thread if blocked or waitting for some resources the other thread still continue to function
- lighter,
   most of the resource of a process are shared by all its thread making it lighter
- thoughput
  it improves the throughput of a multithreaded application, mulitiprocessor environment
- economy
   creating and managing thread is much faster, context switching is faster than performing same task for processes

disadvantages associated with thread
- robustness
  if any one thread is terminated abnormally, it leads to entire process termination
 
process
- is used for heavy task
- are less responsive than threads
- more robust than threads
- each process will have its own address space
- processes have less synchronization overhead since all have separate address space(memory)

thread
- are used for mall task, lightweight
- more responsive than process
- less robust
- threads are within a process thus share same address space9memory)
- Since they share same address space, synchronization is more overhead than process

scheduler
it is one of the compenonet of kernel responsible for scheduling that is deciding when to run which process 

mutex is a kind of semaphore which only allows one thread or process

deadlock
a deadlock is a situation where two or more process or threads sharing the same resource are effectively preventing each other from accessing the resources
the conditions required for deadlock to happene
- mutual exclusion, mutex
- hold and wait
- no preemptyion,
  resources can not be preempted
- circular wait

semaphore
semaphore is one of the simplest synchronization mechianism used to control access to a common resource by multiple processes in a concurrent system 
it is a variabelw with a value range between 0 to N, where N is maximu mresources-1, when it is 1, it is mutex, binary semaphore
- a binary semaphore
  - only takes the vaalues 0 and 1
- a general semaphore
  - can take many positive values 
- suppose a semaphore variable sv
  - P (semaphore variable) for wait
    - if sv is greater than zero, decrement sv,
      if sv is zero, suspend execution of this process
  - S (semaphore variable) for signal
    - if some other process has been suspended waitting for sv, make it resume execution
      if no process is suspended waitting for sv, increment sv
    emaphore sv = 1;
    loop forever {
    P(sv);
    critical code section;
    V(sv);
    noncritical code section;
    }

mutex, 
is a locking mechanism which allows only one process to access the resource at a time

virtual memeory
paging
the mapping from virtual to physical address is done by the memory management unit, MMU, which is a hardware device and this mapping is known as paging technique
it ensures that the physical address of space to be non-contiguous
in this the virtual memory is divided into fixed size pages and the physiccal memory is divided into equal szie called page frames

paging
it is generally a memory management technique that allows OS
to retrieve processes from secondary storage into main memory
it is a non-contiguous allocation technique that divides each process in the form of pages

segmentation
it is generally a memory management technique that divides processes into modules and parts of different areas
these parts and modules are known as sgements that can be allocated to process
in segmentation, we divide the process into modules for better visualization of the process
segmentation divides the user program and the secondary memory into uneven-sized blaocks known as segments

paging divides the memory into some fixed-sized black 
segmentation divides the user program and the secondary emmeory into uneven-sized blocks 

ways to prevent deadlock
- distribute resources in the beginning
- time the lock time

trashing in OS
it is generally a situaion where the CPU performs less productive work nad more swapping or paging work
it spends more time swapping or paging activities rather than its execution

semaphore
is a signaling mechanism
it is simply used to solve the problem or issue of critial sections in the synchronization process by using two atomic operations
wait() and signal()


===
xv6
a kernel, a pecial progra that provides services to running programs
each running program, called a process,
  - has memory containing instructions, data and a stack
  - when a process needss to invoke a kernel service,
      it invokes a system call
      the system enters the kernel
      the kernel performs the service and returns
      thus a process alternates between executing in user space and kernel space

the collection of system calls that a kernel provides is the interface that user programs see
the kernel associates a proceesss identifier or PID with each process

the xv6 shell is a simple implementation of the essence of the Unix Bourne shell.
- shell allows user to redirect I/O
  - ls > out
    cat out
    grep x < out
- shell create a new process to run command
  - shell fork() a process to run ls
    - the child process calls exec()
    - wait(), wait for the child created by fork(), any of its children
       int status;
       wait(&status);
       // the status argument is a way for an exiting child to communicate one integer 32-bit value from the exiting child to the waiting parent
       exit(1);
       // 1 is thee argugment to exit, OS passes 1 from the exiting child to the status.
       // &status, is passing the address of the status variablee to the kernel, the kerneel fills in that address with the child's argument to exit
       // convention in Unix, a program completes successfully it exits with state of zero;
       // if it encoutered an error, the unix convention is that you pass one to exit

- fork
  - a process may craete a new process using the fork system call
  - fork gives the new process an exact copy of the calling process's memory, both instructions and data
  - fork returns in both the original and new processes
    - in the original process, fork returns the new process's PID
    - in the new process, fork returns zero
  - the original and new processes are often called the parenet and child
  - if a given process called fork() twice, and it wannts to wait for both children it has to call wait() twice.
    - each call of wait() wouldd return as soon as one of the children exits,
      you dont neceessarily know which child is exited.
      wait() returns the child's process id, so you can tell after it returns

- exit
  the exit system call casues the calling process to stop executing and to release resourcs such as memory and open files
    - it take an integer status argument
      0 to indicate sucess
      1 to indicate failture

- wait 
  the wait sysem call returns the PID of an exited(or killed) child of the current process and copies the exit status of the child to address passed to wait
  - if none of the caller's children has exited, wiat for one to do so
  - if the caller has no children,, wait immediately returns -1
  - if the parent doesnt care about the exit status of a child, it can pass a 0 address to wait

although the child has the memory contents as the paret initially, the parent and child are executing with separate memry and separate registers

- exec
  - the exec system call replaces the calling process's memory with a new meory with a new memory image loaded from a file stored in the file system
  - the file must have a particular format, which specifies which part of the fil holds instructions, which part is data, at which instruction to start, etc.
  exec takes two arguments
    - the name of the file containing the executable
    - an array of string arguments
  - replaces the calling process with instructions read from a paarticular file
      loads the instrctions from that file over the current process
      discard its current memory, relace the current memory
      then starts eexecuting those instructions
      exec() preserves the current of fd table
      exec() doesnt return, because it replaces its current process's memory
      in additioin you can pass arguments, command line arguments
      cha* argv[] = {"echo","this","is","echo",0};
      // each string is a pointer some memory that contains those bytes
      // 0 marks end of a array, null pointer
      exec("echo",argv); 
  - fork() copied the entire parent process, but exec() throws away all the copied memory and replaces it with whatever is in the file you are runnning
    - lazyfork()
  - exec() a bit expensive
    - load all those instructions
      - access the file system and access the disk
      - read the contents of a file called echo off the disk into memory
      - allocating some memory and freeing some memory from oldd process

- the main sturcture of the shell on xv6
  - reads a line of input from the user with getcmd
  - then it calls fork
  - the parent calls wait
  - the child runs the command

- I/O and file desciptors
  * by defalut, when a program starts, fd 0 is connected to console input, fd 1 is connected to console output
  -  a file descriptor is a samll integer representing a kernel-managed obejct that a process may read from or write to
  - a processs may obtain a file descriptor by opening a file, directory, or device, or by creating a pipe, or by duplicating an existing descriptor
  - by convention, a process
    - reads from file descriptor 0, standard input
    - writes ourpur ro file descriptor 1, standard output
    - writes error messages to file descriptor 2, standard error
  - read(fd,buf,n)
    * fd to the previous opened file
    * buf: pointer to some memory
    - reads at most n bytes from the file descriptor fd, copies them into buf, and returns the number of bytes read
    - each file descriptor that refers to a file has an offset associated with it, read reads data from the current file offset and then adcances that offset by the numberof bytes read: a subsequent read will return the bytes following the ones returned by the first read.
  - write(fd,buf,n) , wrties n bytes from buf to the file descriptor fd and returns the number of bytes written, each write picks up where the previous one left off.
  - the close system call releases a file descriptor, making it free for reuse by a future open, pipe, or dup system call
  - file descriptors and forck interact to make I/O redirection easy to implement
  - open(name, flags) 
      int fd = open("output.txt" OWRONLY|O_CREATE);
      // fd a small number, 2 or 3 or 4
      write(fd, "ooo\n",4);
      * fd index a table in kernel
      * kernel maintains state for each process that is running, each programs you run, a table for every process, index by fd
      * each process has their own space of file descriptor
      * same fd number might refers to different files in different process

- the dump system call duplicates an exciting file descriptor, returning a new one that refers to the same underlying I/O object.
  - both file descriptors share an offset, just as the file descriptors duplicated by fork() do.
  - 
    if(fork() == 0) {
      write(1, "hello ", 6);
      exit(0);
    } else {
      wait(0);
      write(1, "world\n", 6);
    }
    At the end of this fragment, the file attached to file descriptor 1 will contain the data hello world. 
    The write in the parent (which, thanks to wait, runs only after the child is done) picks up where the child’s write left off. 
  - 
    This is another way to write hello world into a file:
    fd = dup(1);
    write(1, "hello ", 6);
    write(fd, "world\n", 6);

- pipes
  a pipe is a small kernel buffer exposed to processes as a pair of file descripts, one for reading and one eof writing
  writing data to one end of the pipe makes that data available for reading from the other end of the pipe
  pipes provide a way for processes to communicate
 
  - three adcantages over temporary files 
    - pipes automatically clean themselves up
    - pipes can pass arbitratily long streams of dara
    - pipes allow for parallel excution of pipeline stages 

- file system
  - inode
    metadatra
  - links

- the Unix system call interace has been standardized through the Portable Operating System Interface (POSIX) standard

- multiplexing
- isolation
  - to achieve strong isolation its helpfil to forbid applications from directly accessing sensitive hardware resources, and instead to abstract the resources into services
  - RISC-V has three modes
    - machine mode
      configuring a computer
    - supervisor mode
      - enabling and disabling interrupts
      - reading and writing the register tht holds the address of a page table 
    - user mode
      - an application can execute only user mode instrctions is said to be running in user space
- interaction

- monolithic kernels
- microkernels

- layout of a process's virtual address space
  MAXVA: trampoline
         trapframe
         heap
         user stack
  0:     user text and data

- the RISC-V page table translates a virtual address to a physical address

- factors that limit the maximum size of  process's address space
  - pointers on the RISC-V are 64 bits wide
  - the hardware only uses the low 39 bits when looking up virtual addresses in page tables
  - and xv6 only uses 38 of 39 bits
  - thus the maximum address is 2^38 -1 = 0x3ffffffff
  - MAXVA -> 0x3ffffffff
- the trampoline page contains the code to transition in and out of the kernel 
- mapping the trapframe is necessary to save/restore the state for each process

- a process bundles two design ideas
  - an address sapce to give a process the illusion of its own memory 
  - a thread to give the process the illusion of its own CPU
  * in real OS, a process may have more than one thread to take advantage of multiple CPUs.

===
starting xv6, the first process and system call

- when a RISC-V computer powers on, it initializes itself and runs a boot loader which is stored in read-only memory
- the bootloader loads he xv6 kernel into memory
- in machine mode, the CPU executes xv6 starting at _entry
- the RISC-V starts with paging hardware disable: virtual address map directly to physcial addresses
- the loader loads the xv6 kernel into memory at physical address 0x800000000.
  - the reason it places the kernel at 0x800000000 rather than 0x0 is because the address range 0x0 -> 0x800000000 contains I/O devices
- the instructions at _entry set up a stack so that xv6 can run C code
- xv6 declares space for an initial stack, stack0
- the code at _entry loads the stack pointer register sp with the address stack0+4096, the top of the stack. because the stack on RISC-V frows down.
- now that the kernel has a stack, _entry calls into C code at kernel/start.c

- the function start performs some configuration that is only allowed in machine mode and then switches to supervisor mode
- to enter supervisor mode, RISC-V provides the instruction mret
  - the instruction mret is most often used to return from a previous call from supervisor mode to machine mode
  - start isn't returning from such a call, and 
  - instead sets things up as if there had been one: it sets the previous privilege mode to supervisor in the register mstatus, 
  - it sets the return address to main by writing main's address into the register mepc, 
  - disables vitrual address translation in supervisor mode by writing 0 into the page-table register satp,
  - and delegates all interrupts and exceptions to supervisor mode
- before juming into supervisor mode, start performs one more task: it programs the clock chip to generate timer interrupts
- after all that, start "returns" to supervisor mode by calling mret
- that would cause the program counter to change to main
- after main initilizes several devices deices and subsystems, it creates the first process by calling userinit
- the first process executes a small program written in RISC-V assembly, which makes the first system call in xv6
- initcode.S loads the number of the exec system call, SYS_EXEC into register a7 and calls ecall to re-enter the kernel
- the kernel uses the number in register a7 in syscall to call the desired system call
- the system call table maps SYS_EXEC to sys_exec, which the kernel invokes
- once the kernel has completed exec, it returns to user space in the /init process
- init creates a new console device file if needed and then opens it as file descriptors 0,1, and 2. then it starts a shell on the console. the system si up

- security
  - the OS must assume that a process's user-level code will fo its best to wreck the kernel or other processes
    - try to dereference pointers outside its allowed address sapce
    - it may attempt to execute any RISC-V instructions
    - try to read and write any RISC-V control register
    - it may try to directly access deivce hardware
    - it may pass clever values to system calls in an attempt to trick the kernel into crashing or doing somethin stupid

===
page table
- page tables are the most popular mechanism through which the OS provides wach process with its own private adress space and memory
- page tables allow xv6 to isolate different process's ddress spaces and to multiplex them onto a single physical memory

- RISC-V instructions (both user and kernel) manipulate virtual addresses.
- the machine's RAM, or physical memory is indeed with physical addresses
- the RISC-V page table hardware connects these two kinds of addresses, by mapping each virtual address to a physical address

- xv6 runs on sv39RISC-V, means only the bottom 39 bits of a 64-bit virtual address are used, the top 25 bits are not used
- in this sv39 configuration, a RISC-V page table is logically an array of 2^27, 134217728 page table entries (PTEs).
- each PTE contains a 44-bit physical page numebr (PPN) and some flags
- the paging hardware translates a virtual address by 
  - using the top 27 bits of the 39 bits to index into the page table to find a PTE,
  - and making a 56-bit physcial address whose top 44 bits come from the PPN in the PTE
  - and whose bottom 12 bits are copied fromthe original virtual adress
  virtual address 64:
       |index |offset
    25 |27    |12     -------------------
         |                              |
         |  44 | 10                     | 
         -> PPN| flags                  | 
             |                          |
             ------------------------   |
                                    |   |
                                    v   v
              physical address 56: 44| 12

- a page table gives the OS control over virtual to physical address translations at the granularity of aligned chunks of 4096(2^12) bytes. suck a chunk is called a page
- in sv39 RISC-V, th top 25 bits of a virtual address are not used for translation, the physcial address also has room for growth, 2^39 = 512 GB, shoudl be enough

- a RISC-V CPU translates a virtual address into a physial address in three steps:
  - a page table is stored in physical memory as a three-level tree:
    - the root of the tree is a 4096-byte oage-table page that contains 512 PTEs
      - which contain the physical addresses for page-table pages in the next level of the tree
    - the paging hardware uses the top 9 bits of the 27 bits to select a PTE in the root page-table page
    - the middle 9 bits to selet a PTE in a page-table page in the next level of the tree
    - and the bottom 9 bits to select the final PTE

- if any of the three PTEs required to translate an address is not present, the paging hardware raises a page-fault exception, leaving it up to the kernel to handle the exception

- the three-level structure allows a memory-efficient way of recording PTEs, compared to the single-level design
- one down side:
  - CPU must load three PTEs from memory to perform the translation of the irtual address in the load/store instruction to a physical address
    - to avoid the cost of loading PTEs from physical memory, a RISC-V CPU caches page table entries in a Translation Look-aside Buffer (TLB)
  
- each PTE contains flag bits that tell the paging hardware how the associated virtual ddress is allowed to be used
  - PTE_V indicates whether the PTE is present,
      if it is not set, a reference to the page causes an exception
  - PTE_W controls whether instructions are allowed to write to the page
  - PTE_R controls whether instructions are allowed to read to the page
  - PTE_U controls whether instructions in user mode are allowed to access the page
      if it us not set, the PTE can be used only in supervisor mode
  - PTE_X controls whether instructions the CPU may interpret the content of the page as instruction and execute them

- to tell a CPU to use a page table, the kernel must write the physical address of the root page-table page into the satp register
  - a PCU will translate all addresses generated by subsequent instructions using the page table pointed to by its own satp
  - each CPU has its own satp so that different CPUs can run different processes, each with a privte address space described by its own page table
  
- physcial memory refers to storage cells in DRAm
- A byte of physical memory has an address, called a physical address
- instructions use only virtual address, which the paing hardware translates to physcial address,
  - and then send to the DRA hardware to read or write storage.

- xv6 maintains one page table per process, describing each process's user address space, plus a single page table that describes the kernel's address space

- the kernel gets at RAM and memory-mapped device registers using irect mapping
  - that is mapping the resources at virtual addresses that are equal to the physical address
    - for example, the kernel itself is located at KERNBASE = 0x80000000 in both virtual and physical memory
    - direct mapping simplifies kernel code that reads or writes physical memory
    - For example, when fork allocates user memory for the child process, the allocator returns the physical address of that memory; fork uses that address directly as a virtual address when it is copying the parent’s user memory to the child.
  - a couple of kernel virtual addresses that aren't direct mapped:
    - the tranpoline page
      - it is mapped at the top of the virtuaal addresss space
    - the kernel stack pages
      - each process has itw own kernel stack
      - which is mapped high so that below it xv6 can leave an unmapped guard page
      - the guard page's PTE is invaild (PTE_V is not set)
      - so that if the kernel overflows a keernel stack, it will likelt caause an exceeption and kernel will paanic
      - without a guard page an overflowing stack would oveerwrite other kernell memory, resulting in incorrect operation. a panic crash if preferrable

- creating an address space
  - the central data structure is pagetable_t, which is a pointeer to aa RISC-V root page -table page

===
* the processs model
  - sequential processes
  - a process is an instance of an executing program, including the value of the program counter, registers and variables 

- process creation
  - system initialization
  - execution of a process-creation system call by a running processs
  - a user request to create a new process
  - initiation of a batch job

- process termination
  - normal exit, voluntary
  - error exit, voluntary
  - fatal error, involuntary
  - killed by another process, ivoluntary

- process states
  - running, actually using the CPU at that instant
  - ready, runnbale, temporarily stopped to let another process run
  - blocked, unable to run until some external event happens

- implementataion of processes
  - process table, aka, process control blocks
    - to implement the process model, the operating system maintains a table, an array of structures, with one entry per process
    - some of the fields of a typical process table entry:
      - process management
      - memory management
        - pointer to text segment info
        - pointer to data segment info
        - pointer to stack segment info
      - file management
    - this entry contains important information about the process' state, like, program counter, stack pointer, memory allocation, the status of its open files, its accounting and scheduling information and everything else about the process that must be saved when the process is switched from running to ready or blocked state so that it can be restarted later
      - all interrupts start by saving the registers, often in the process tbale entry for the current process
      - and then the inforamtion pushed onto the stack by the interrupt and then they are removed and the stack pointer is set to point to a temporary stack used by the process handler

* process
- each process provides the resources needed to execute a program
- each process is started with a single thread, the primary thread
* thread
- a thread is an entity with in a process that can be scheduled for execution.
- the ability for the parallel entities to share an address space and all of its data among themselves
- threads are lighter weight than processses
- threads are useful on systems with mulitiple CPUs, where real parallelism is possible
- threads run in a shared memory space (of the same process)
- processes run in separate memory spaces

- threads, parallelism, blocking system calls
- single-threaded process, no parallelism, blocking system calls
- finite-state machine, parallelism, nonblocking system calls, interrupts

- process
  - it is a way to group related resources together
  - a process has an address space containning program text and data as well as other resources

- thread
- a process as a thread of execution

- processes are used to group resources together
- threads are the entities scheduled for execution on the CPU

- Pthreads from IEEE
  - pthread_create
  - pthread_exit

- implement threads in user space
  - put the threads package entirely in user space
    - implemented by a library
  - thread table to keep track of the threads in that process

- InterProcess Comunication, IPC
  - race condition
    - situation when two or more  processes are reading or writing some shared data and the final result depends on who runs precisely when
  - mutual exclution
    - some way of making sure that if one process is using a shared variable or file, the other processes will be excluded from doing the same thing
  - cirtical region, critical section
    - where the shared memory is accessed
    - range matters such that no two processes were ever in their critical region at the same time to avoid races

- mutal exclusion with busy waiting
  - disabling interrupts
    - on a single-processor system, the simplesy solution is to have each process disble all interrupts just after entering its critical region and re-enable them ust before leaving it
    - with interrupts disabled, no clock interrupts can occur
    - with a multiprocessor system ( with two or more CPUs) disabling interrupts affects only the CPU that executed the disable instruction. the other ones will continue running and can access the shared memory
  - lock variables
    - read a lock before entering its critical region
  - strict alternation
    - continously testing a variable until some value appears is called busy waiting
      - it should usually be avoided, since it wastes CPU time
      - only when there is a reasonable expectation that the wait will be short is busy waiting used
      - a lock that uses usy waiting is called a spin lock

  - peterson's solution
    - enter_region()
    - leave_region()
  - the TSL instruction
    - test and set lock 
    - it reads the contents of the memory word lock into register RX 
    - and then stores a nonzero value at the memory address lock
    - the operations of reading the word and storing into it are guaranteed to be indivisible
      - no other processor can access the memory word until the instruction is finished
    - the CPU executing the TSL instruction locks the memory bus to prohibit other CPUs from accessing memory until it is done, hardware on the bus line
    - an altternative instruction to TSL is SCHG
      - which exhanges the contents of two locations atomically
        - TSL REGISTER, LOCK
          CMP REGISTER, #0
        - MOVE REGISTER, #1
          XCHG REGISTER, LOCK
          CMP REGISTER, #0
  - both peterson's solution and the solutions using TSL or SCHG are correct, but both waste CPU time
    - priority inversion problem
  - slepp and wakeup
    - sleep is a systemc all that causes the caller to block, thay is be suspended until another process wakes it up
    - the wake up call has one parameter, the process to be awakened

- semaphore
    - a semaphore could have the value 0, indicating that no wakeups were saved
    - or some positive value if one or more wakeups were pending
    - down and up operation
      - the down operation on a semaphore checks to see if the value is greater than o 
        - if so, it decreaments the vlaue (uses up one stored wakeup) and just continues
        - if the value is 0 the process is put to sleep wihtout completing the down for the moment
      * checking the vlaue, changing it and possibly going to sleep are all done as a single indiisible aromic action
      - the up operation increments the value of the semaphore addressed
        - if one or more processes were sleeping on that semaphore with processes sleeping on it, the semaphore will still be 0, but there will be one fewer process sleeping on it

- mutexes
    - a simplified version of the semaphore, binray semaphores
    - when the semaphore's ability to count is not needed
    - a shared vaiable, two states, unlocked or locked

* memory management
  - memory hierarchy





* scheduling
- scheduler

- scheduling algorithm

* ecall
- change mode from user to superviosr
- save PC and sepc (supervisor exception program counter)
- jump to the insturction that stvec points to 

* implement virtual memory features using page faults
- lazy allocation
- copy, write, fork
- demand paging
- mma, memory map files
 
- the faulting virtaul address
- the type of page fault
- the virtual address of the instruction ythat caused the fault
  - sepc, supervisor exception progrm counter in the trap frame, epc

* virtual memory
- isolation
- level of indirection
  - virtual address -> physical address
    - trampoline
    - guard page
    - static mapping
      - using page faults, we change the mapping
 
- overlays
  - split programs into little pieeces, called overlays

- virtual meemory
  - each program has its own address space
  - which is broken up into chunks called pages
  - each page is a contiguous range of addressses

- virtual memory -> MMU (mmeory management unit) -> memory bus
- the virtual address space consists of fixed-size units called pages 
- the correspondingg units in physical memory are called page frames
- the relation betweeen virtual addresses and physcial memory addresses is given by the page table
- if the program references an ummapped address (present/absent bit) -> page fault

- TLB, translation lookaside buffer, associative memory
  - MMU first look up TLB, and then does an ordinary page table lookup
    - if miss in TLB, replacee the entry
    - wont cause trap, traps only occur when a page is not in memory
    - TLB misses occuur much more frequently than page faults
      - soft miss, not in TLB, but in memory
      - hard miss,, not in TLB and memory
        - a disk aaccess is required to bring in the page
      - minor page fault
      - major page fault
      - segmentation fault, invaild access

* deadlock
- preemptable resource
- nonpreemptable resource

- four conditions must hold for theree to be a resource deadlock
  - mutual exclsusion condition
  - hold anad wait condition
  - no preemption condition
  - circular wait condition

* SSH
  - secure shell protocol
    - a remote admnistration protocol that allows users to accress, control and modify their remote servers over the internet
    - it provides a mechanism for authenticating a remote user
  - ssh {user} @{host}

* terminal tricks
- ctrl F forward by a ward
- ctrl B backward by a ward
- ctrl P last command
- ctrl N next command
- ctrl a the begining
- ctrl e the end 

* ifconfig
- a network interface
  - is the point of conection between a computer and a network
- Linux distinguishes two types of network interface
  - the physcical network interface
    - a network hardwaree device such as 
      - NIC (network interface card),
      - WNIC (wireless network interface card)
      - a modem
  - the virtual network interface
    - linked to a network device
  - ls /sys/class/net
  - ip link
  - ifconfig
  - ip addr

* differential signaling, CAN
  - ground is noise, signal is noise
  - those two wires are set up to always show the exact opposite signal of its companion wire
    
* can-util
- for virtual CAN interface
  sudo modprobe vcan
  sudo ip link add dev vcan0 type vcan
  sudo ip link set up vcan0
- for native interface
  - slcand
    - userspace daemon for serial line CAN interface driver SLCAN
  sudo ip link set can0 type can bitrate 125000
  sudo ip link set up can0
- cangen van0
  - candump van0
    - candump -l van0
      - candump would log the can frames
- canplay
  - it would replay the can frames  
  - canplay -I canfile.log
- cansniffer
  - CAN sniffer is used to see thee change in CAN traffic
  - cansniffer -c vcan0

