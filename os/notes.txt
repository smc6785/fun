# setup
- Download kernel source code
- Compile the kernel
- .config file under Linux
  - zcat /proc/config > .config
  - cp /proc/config.gz ./
    gunzip ./config.gz
    mv config .config
- make menuconfig, to edit the config file
- make xconfig, to edit the config file
- make oldconfig, for older confile file with a newer version of kernel
- uname -a, to see the current running kernel

# make kernel
- make -j8
  - nproc
- make module_install
  - ls /lib/modules/5.12.0-rc6-MANJARO/
- make install
  - ls /boot/
- cp /boot/vmlinuz /boot/vmlinz-$(make kernelversion)-$(uname -m)
- /boot/grub/grub.cfg
  - problem with editting this .config file:
    - update-grub would over write .config file
  - instead, edit /etc/grub.d/40_custom
- cat /etc/mtab

# make kernel module
- kernel header files
- make -C /lib/modules/$(uname -r)/build M=$(pwd)
- sudo insmod ./helloworld.ko
- sudo rmmod helloworld
- sudo dmesg -C, to clean kernel log ring buffer
- load kernel module in system start
  - /etc/modules-load.d/modules.conf
  - this would load modules with modprobe
  - modprobe is looking for modules dependencies
  - move .ko under that directory

# module param
- int gpio_pin = 18;
  module_param(gpio_pin, int, 0);
  MODULE_PARM_DESC(gpio, "GPIO-pin ID";

# char device/ character device
- cat /proc/devices, device number
- dev_t devno;
  devno = MKDEV(137, 0);
  // 137 major number, 0 minor number
  register_chrdev_region(devno, 1, "gpio_morse");
  unregister_chrdev_region(devno, 1);
- struct file_operations my_fops = {
    ...
  };
  struct cdev my_cdev;
  cdev_init(my_cdev, &my_fops);
  cdev_add(&my_cdev, devno, 1);
- mknod /dev/gpio_morse c 137 0
- each "hello" > /dev/gpio_morse

========
# busybox
- wget busybox and linux kernel
- make linux kernel
- make busybox
  - systems can not load dynamically linked library
  - we need to create a static build for busybox
  - musl-gcc ?
- busybox is using arg 0 to check its own file name
  - rename busybox to echo
  - ln -s /bin/busybox echo
  - ./echo "hello world"
  - busybox --list
- find . | cpio -o -H newc > ../initrd.img
- qemu-system-x86-64 -kernel bzImage -initrd initrd.img -nographic -append 'console=tty50'

========
# kernel
- MMU, memory management unit 
  - It is the hardware responsible for implementing virtual memory
  - TLB, tranlation lookaside buffer
    - A list of mappings from virtual to physical address
    - Part of MMU
    - TLB is consulted by the MMU when the CPU accesses a virtual address
      - If the virtual address is in TLB,
        - MMU can look up the physical resource
      - If the virtual address is not in TLB, or the permissions are insufficient
        - MMU will generate a page fault exception and interrupt the CPU
          - A page fault is when software attempts to use an invalid virtual address
  - MMU operates on basic units of memory called pages
    - Page size varies by architecutre
  - A page is a unit of memory sized and aligned at the page size
  - A page frame, or frame refers to a page-sized and page-aligned physcial memory block
    - pfn, page frame number
  - A memory map for a process will contaion many mappings
  - A mappiing often covers multiple pages
  - The TLB holds each mapping virtual address, physical address, permissions
  - Each process has its own set of mappings
    - The same virtual addresses in two diffrent processes 
      will likely be used to map different physical addresses
- In Linux, both kernel and user space uses virtual addresses
  - The upper part is used for the kernel
  - The lower part is used for user space
  - On 32-bit, by default the split is at 0xC0000000
    - Kernel 1GB, 0xFFFFFFFF to 0xC0000000
      - Kernel address space is the area above CONFIG_PAGE_OFFSET
    - User space 3GB, 0x00000000 to 0xC0000000
  - On 64-bit, the spli varies by architecture
    - 0x8000000000000000 for ARM64
    - 0xFFFF880000000000 for x86_64
  - three kinds of virtual addresses
    - Kernel logical address
      - Normal address space of the kernel
      - kmalloc()
      - They are a fixed offset from their physical addresses
        - Virtually-contiguous regions, also physically contiguous
        - Virtual: 0xC0000000 <-> Physical: 0x00000000
      - __pa(x) and __vs(x)
      - Contains allocated memory and kernel stacks(per process)
      - Kernel logical memory can never be wapped out
      - For 32 bit large RAM system:
        - Low memory
          - Physical memory which has a kernel logical address
          - Physically contiguous
        - High memory
          - Physical memory beyond 806MB (1GB- 104MB(for virtual kernel memory))
          - Has no logical address
          - Not physically contiguous
          - only on 32-bit
    - Kernel virtual address
      - The addresses in the region above the kernel logical address mapping
      - Also called vmalloc() area
      - Non-contiguous memory mappings
        - Large buffers which could be potentially be too large to find contiguous memory
      - Memory-mappped I/O
        - Map peripheral devices into kernel
          - PCI, Soc IP blocks
        -- ioremap(), kmap()
    - User virtual address
      - Memory used by user space programs
      - All addresses below PAGE_OFFSET
      - Not contiguous, can be swapped out, can be moced
      - Only used portions of RAM are mapped
      - Each process has its own memory map
        - struct mm, pointers in task_struct
    - Pages, divide physical memory in fixed-size blocks
      - Typical page size 2^p: 4KB - 16 KB
      - virtual page number | offset
# virtualization
- A running progarm plus its context is called a process
  - All register state, stock pointer, program counter
  - Program code, stack and heap
- A special control process manages all other processes
  - Control process runs in kernel mode or protected mode
  - Controller performs context-switches
    - Suspend the currently running procesds, copy context to memory
    - Copy another process's context into running area and then resume it

a tour of the ARM architecture and its linux support
https://www.youtube.com/watch?v=NNol7fRGo2E&ab_channel=linuxconfau2017-Hobart%2CAustralia

# ARM: architecture specification
- the specification of the ARM architecture
- over time, improvements of the architecture, with numerous versions: ARMv4, ARMv5, ARMv6, ARMv7, ARMv8
- take the form of voluminous documentation, named ARM ARM, ARM Architecture reference manual

# ARM cores: an actual implementation
- ARM creates IP cores that implement the specification
- IP core = implementation in VHDL or Verilog of a block of hardware logic 
	- ARM926 = implementation of ARMv5
	-	ARM1176 = implmentation of ARMv6
	- Cortex-A15 = implementation of ARMv7-A
	- Cortex-A53 = implementation of ARMv8-A
- multiple possible implementations for the same architecture specification
 	- exmaple: all of Cortex-A5,7,8,9,12,15 implement the smae ARMv7-A architecture ( with some additions in some cases)
	- Cortex-A5 is a low-power lower-performance implementation, Cortex-A15 is a very high-performance and more power hungry implmentation
	- difference in internal implementation: depth of the pipeline, out of order execution, size of caches, tec.
- this is NOT hardware: ARM doesnot sell silicon

# ARM system-on-chip
- System-on-chip: integrated circuit that integreatees all components of a computer system
	- CPU, but also peripherals: Ethernet, USB, UART, SPI, I2C, GPU, display, audio, etc.
	- Integrated in a single chip: easier to use, more cost effective
- SoC vendors:
	- buy an ARM core from ARM
	- integrate other IP blocks, either designed internnally, or purchased from other vendors
	- create and sell silicon
- large spectrum of SoCs available, addressing very different markets: automotive, mobile, industrial, low-power, set-top box, etc.

# ARM hardware platform
- even though an SoC is a full system on a chip, it is generally not self-sufficient
	- RAM, NAND flash or eMMC, power circuitry
	- display panel and touchscreen
	- wifi and bluetooth chip
	- ethernet PHY
	- HDMI transceiver
	- CAN transceiver
	- connectors
- SoC conencted to a wide varity of peripherals, through various busses
- laid out on a PCB, with commponents soldered on it

# ARM: from the architecture to the board
arm architecture:
	ARMv5, ARMv7-A
|
v
ARM core implementation:
	ARM926, ARM Cortex-A8
|
v
system on chip:
	Atmel AT91SAM9G20, Allwinner R8
|
v
harware platform
	Raspberry Pi, your phone,car,TV

# example of ARM boards:
	- raspbeeryPi 1
		- Soc: Broadcom 2835
		- ARM core: ARM1176JZF (single)
		- ARM architecture: ARMv6
	- raspbeeryPi 2
		- Soc: Broadcom 2836
		- ARM core: Cortex-A7 (quad)
		- ARM architecture: ARMv7-A

# linux support
* three levels of hardware, three levels of software support
	- the ARM core
	- the SoC
	- the board
* supporting a platform with just the serial port and Ethernet is very different from fully supporting a platform (graphics, audio, power management, etc.)

# three ARMv7-A variants
- ARMv7-A, where A stands for applcaition
	- fulll-featured variant designed for complex operating systems such as linux
	- has a memory management unit (MMU), caches, supports ARM and Thumb2 instruction sets, high performance, VFP and NEON instructions
	- cores: Cortex-A8, Cortex-A15

- ARMv7-M, where M stands for microcontroller
	- much maller variant: no MMU, no caches until recently, supports only Thumb2, low performance but also low power
	- cores: Cortex-M3, Cortex-M4, Cortex-M7
	- generally runs bare metal code, or a small real-time operating system. Linux has support for them, but requires external RAM and flash

- ARMv7-R, where R stands for real-time
	= reduced version of the A profile, with focus on deterministic respinse
	- widely used in storage devices (hard drive and SSD controllers)
	- typically doesnt run linux

# ARMv8:
	- introduction of AArch64, a new instruction set with 64 bits support (AArch64 support is optional, some ARMv8 cores do not support it)
	- also supports a mode called AArch32, which offers backward compatibility with ARMv7-A
	- ARMv8 cores: Cortex-A32 (32 bits only), Cortex-A53, Cortex-A57, Cortex-A72, etc.

# architecture licensees
- most SoC vendors buy ARM cores from ARM, i.e Cortex-A15 or Cortex-A57
- A few SoC vendors however have an architecture license
- they pay a fee to be allowed to create a CPU core that implements the same CPU architecture, but do not use the ARM cores
- examples:
	- Qualcomm Scorpion, Qualcomm Krait (ARMv7)
	- Apple Swift (ARMv7, used in the A6)
	- NVidia Denver (ARMv8)
	- Cavium, Broadcom, Qualcomm, Samsung (ARMv8)
* ARM architecture specification ->
	Apple core implementation, apple swift ->
	system on Chip, Apple A6 ->
	hardware platform, iphone

# lack of standardization
- ARM architecture specified: instruction set is compatible between all ARMv7 cores, between all ARMv8 cores
	- can run Linux, Ubantu (built for ARMv7) on any ARMv7 platform
	- however, Ubuntu (built for ARMv7) will not run on RaspberryPi 1 (ARMv6)
- almost no standardization for the other hardware components: inside the SoC and on the board
	- need specific handling at the bootloader and linux kernel level for each SoC and board
	- on most ARM SoCs, the hardware inside the chip is memory-mapped. No dynamic discovery/enumeration capability

# hardware re-use
- compatibility of procesor cores: they comply with ARM specification
- for the other hardware blocks, SoC vendors very often
	- purchase IP blocks from third-party vendors: ARM, Cadence, Synopsys, Mentor Graphics, Imagination technologies, etc.
	- extensively re-use IP blocks between their different SoCs
- example:
	- Mentor graphics MUSB (USB gadget controller) is used in TI, Allwinner and ST SoCs, but also on Blackfin and some MIPS processors
	-	the Marvell SPI controller is re-used in Marvell processors shipped over 15 years, from old ARMv5 Orions to modern ARMv8 processors
- massive re-use drivers

# BIOS
- in terms of booting process, no standardized BIOS or firmware like on x86 machines
- each ARM SoC comes with its own ROM code that implements a SoC-specific boot mechanism
- the early stages of the boot process are therefore specific to each SoC
- in general. capable of loading a small amount of code from non-volatile storage(NAND, MMC, USB) into a SRAM internal to the processor. (external DRAM not initil=alized yet)
- often also provides a recovery method, to unbrick the platform. Over USB, serial or somethimes Ethernet.
- used to load a first stage bootloader into SRAM, which will itself initialize the DRAM and load/run a second stage into DRAM

# bootloaders
- Grub(2) typically not widely used on ARM platforms
- U-boot, the de-facto standard, found on most developemnt boards and community playforms
- barebox, less widely used, but very interesting
- homemade bootloaders, especially when security/DRM are involved
- Grub starts to gain some traction, especially on ARM64, for the server market
- RaspberryPi is very special case, with some firmware executed on the GPU, and directly loading the linux kernel

# bootloaders (2)
- first stage bootloader provided either by:
	- a seperate project. Example: AT91Bootstrap for Atmel platforms
	- U-boot/Barebox itself. Concept of SPL: minimal version of the bootloader that fits in the constrants of the first stage
- interaction with the bootlaoder typically over the serial port
	- U-boot and Barebox offer a shell, with bootloader specific commands
	- Sometimes screen/keyboard interaction possible, but not the norm
	- embedded without a  serial port is weird

# booting process diagram
- ROM code, stored inside the SoC, in ROM
- 1st stage, stored in NAND, SPI flash, USB, SD, runs form internal SRAM
- 2nd stage, stored in NAND, SPI flash, USB, SD, runs form DRAM
- linux kernel

# describing hardware
- on x86, most hardware can be dynamically discovered at run-time
	- PCI and USB procide dynamic enumeration capabilities	
	- for the rest, ACPI provides tables describing hardware
	- thanks to this, the kernel doesn't need to know in advance the hardware it will run on
- on ARM, no such mechanism exists at the hardware level
	- in the old days (prior to 2011), the kernel code itself contains a description of all hardware platforms it had to support
	- in 2011, the ARM kernel developers switched to a different solution for hardware descriptionL: device tree
	- done together with an effort called multiplatform ARM kernel

# device tree
- a tree of nodes describing non-discoverable hardware
- providing information such as register addresses, interrupt lines, DMA channels,type of hardware, etc.
- provided by the firmware to the operating system
- operating system agnostic, not linux specific
	- can be used by bootloaders, BSDs, etc.
- originates from the PowerPC world, where it has been in use for many more years
- source format written by developers (dts), complied into a binary format understood by operating systems(dtb)
	- one .dts for each hardware platform

# device tree: in practice
- used for almost all ARM platformss in linux and all all ARM64 ones
- used for a dew platforms in bootloaders such as U-Boot or Barebox
- Device tree source code stored in the Linux kernel tree
	- duplicated in U-Boot/Barebox source code as needed
	- plan for a central repository, but never occurred
- supppoesd to be OS-agnostic and therefore backward compatible
	- in practice, are changed quite often to accommodate linux kernel changes
- loaded in memory by the bootloader, together with the lunux kernel image
- parsed by the linux kernel at boot time to know which hardware is available

# Linux kernel
- support for the ARM core is generally done by ARM engineers themselves
	- MMU, caches, virtualiztion, etc.
	- in arch/arm and arch/arm64
	- generally in linux upstream even before actual ARM SoCs with this core are available
- support for the ARM SoC and hardware platform is a different story
	- requires drivers for each and every hardware block. inside the SoC and on the board in drivers/
	- requires device tree desciptions in arch/arm(64)/boot/dts
	- sometimes supported only in vendor forks, sometimes supported in the upstream linux kernel
	
# Linux kernel: typical support fotr an SoC
- core drivers
	- clock controller, drivers/clk
	- reset controller, drivers/reset
	- pin-muxing controller, drivers/pinctrl
	- interrupt conreoller, drivers/irqchip
	- timers, drivers/clocksource
	- GPIO controllers, drivers/gpio
- peripheral drivers
	- bus controllers:
		- I2C, drivers/i2c
		- SPI, drivers/spi
		- USB, drivers/usb
		- PCI, drivers/pci
	- display controller, drivers/gpu/drm
	- camera interface, drivers/media
	- touchsreen or other input devices, drivers/input
	- ethernet controller, drivers/net
- platform code
	- on ARM, minimal amount of platform code in arch/arm/mach-<foo> for power management and SMP support
	- on ARM64, no platform code at all, power management and SMP activities handled using PSCI

# Linux kernel: from vendor to up stream
- most vendors fork the linux kernel, and add support for their SoC to their own fork
- leads to kernel forks with sometimes millions of added lines for SoC support
	- users can not easily change/upgrade their kernel version
	- generally of poor quality
	- situation got somewhat worse with Android
- some vendors engage with the upstream linux kernel community, and submit patches
	-	more and more vendors taking this direction
	- Mileage may bary depending on the vendor, and sometimes the SoC family
- thee community also significantly contributes to upstream Linux kernel support for ARM SoCs
	- example: Allwinner support is fully community-contributed, no involvement from the vendor

# Linux kernel: going multiplatform
- originally, on ARM, a compiled kernel image could only boot on a reduced set of platforms, all using the same SoC
	- lots of compile-time conditionals
- wish to have a behavior more similar to x86, with one single binary kernel that works for all platforms
- effort started around making the ARM kernel multiplatform
	- handle more things at runtime rather than at compile time
	- part of a larger cleanup effort: switch to device tree, addition of numerous driver subsystems
- one can now build a single kernel for ARMv4/v5, a single kernel for ARMv6/v7, and a single kernel for ARMv8
	- make ARCH= arm multi_v7_defconfig
	
# root filesystem
* the root file system is the top of the hierarchical file tree. It contains the files and directories critical for system operation, including the deivce directory and programs for booting the system
- regular desktop-style distributions: Debian, Ubuntu, Raspbian, Fedora, etc.
- specialized systems: Android, Tizen, etc.
- embedded Linux build system
	- widely used for embedded system
	- produce a Linux root filesystem through cross-compilation
	- allows a much more customized and stripped down system than a fyll-blown distribution
	- examples: OpenEmbedded/Yocto, Buildroot, OpenWRT, etc.
----------------------------------------------------------

application
library
kernel
BIO
hardware

# include <sttdio.h>
int main(void)
{
	printf("hello world!\n")
}
$gcc -Wall hello.c -o hello
$./hello
$objdump -d hello
.elf file, executable and linkable format
a binary file written on disk that when you execute it 
it goes into the kernel, the kernel would read the header file and knows how to parse elf files
it's going to load parts with a file into various segments of memory
and it's going to jump to a location

printf("hello world\n %p where main is\n", &main);
the address of main is different every time, except the last three digits
every you load anything into the kernel, its gonna to randomly palce it in virtual address space
elf files are made, so you can be executed anywhere
thats why you had the offset from the instruction pointer, not just a hard-coded address space for those parameters, the string and for the value

address spcce doesnt equal to memory,
it also includes access to devices or something else

# system call
- this is the interface into the kernel from the application
- tells the kernel what you want to do
	- open a file
	- read the network
	- write a file
	- etc
- an application programming interface (API)
- they do not change (once one is made, it must be backward capatible)

# strace
- sytem call tracer
- see the interface into the kernel
- traces all system calls
- uses ptrace, same as gdb
--------------------------

Linux doesn't usually run on Cortex-M, 8051, AVR, other other popualr microcontroller architectures. Instead, we use application processor-popular ones are the ARM Cortex-A, ARM926EJ-S, and several MIPS iterations
microprocessors have a memory management unit(MMU), and microcontrollers don't.

# dynamic memory allocation
- small microcontroller applications can usually get by with static allocations for everything. As your application grows, you'll find yourself calling malloc() more and more.
* malloc(), from the C standard library
* void *malloc(size_t size) allocates the requested memory and returns a pointer to it
* size, this is the size of the memory block, in bytes
- with complex, long-running systems, thins would crash at random times.
	- they almosy always stem from memory allocation issues
		- memory leaks (that can be fixed with appropriate free() calls)
		- memory fragmentation (when the allocator runs out of appropriately-sized free blocks)
- because Linux capable application processor have a memory management unit, *alloc() calls execute swiftlly and reeliably.

# software workflow
- when building embedded Linux systems, we need to start by compiling all the off-the-shelf software we plan on running - the bootloader, kernel, and userspace libraries and applications.
- five components that fo into every modern embedded Linux system
	- A coress toolchian, susally, GCC+glibc, which contains your comiler, binutils, and C library. This doesnt't actually go nto your embedded Linux system, but rather is used to build the other components
	* glibc, GNU C library
	* two lightweight C libraries, musl libc and uClibc-ng, which implement a subset of features of the full glibc
	- U-boot, a bootloader that initializes your DRAM, console, and boot media, and then loads the Linux Kernel into RAM and starts executing it
	- the Linux kernel itself, which manages memory, schedules processes, and interfaces with hardware and networks
	- busybox, a single executable that contains core userspace components (init, sh, ect)
	- a root filesystem, which contains the aforementtioned userspace components, along with any loadable kernel modules you compiled, shared libraries and configuration files	

# U-boot
- unfortunately, our CPU's boot ROm cant directly load our kernel.
- Linux has to be invoked in a specific way to obtain boot arguments and a pointer to the device tree and initrd (initial ramdisk),
   and it also expects that the main memory has already been initialized.
- Boot ROMs also don't know hot to initialize main memory, so we would have nowhere to store Linux.
- boot ROMs tend to just load a few KB from flash at the most, not enough to house an entire kernel, 
  so we need a small program that the boot ROM can load that will initilized our main memory and then load the entire (usually-multi-megabyte) 
  linux kernel and then execute it.
- the most popular bootloader for embedded systems, Das U-boot, does all of that,
   but adds a ton of extra features it has a fully interactive shell, scripting support, and USB/network booting
- U-boot has to know a lot of technical details about your system. There's a dedicated board.c port for each supported platform
 that initializes clocks, DRAM, and relevant memory peripherals, along with initializing any important peripherals,
 like your UART console or a PMIC that might need to be configured properly before bringing the CPU up to full speed
- newer board ports often store at least some of this configuration inofrmation inside a device tree.
- some of the the DRAM configuration data is often autodetected, 
  allowing you to change DRAM size and layout without altering the U-boot port's code for your processor
- you configure what you want U-boot to do by writing a script that tells it which device to initialize, 
  which file/address to load into which memory address, and what boot arguments to pass along to Linux.

# Linux Kernel
- once U-boot turns over the program counter to Linux, the kernel initializes itself, 
  loads its own set of device drivers and other kernel modules, and calls your init programs
-	one big difference between embedded Linux and desktop Linux is that 
  embedded Linux systems have to manually pass the hardware configuration information to Linux through a Device tree file or platform data C code, 
  since we don't have EFI or ACPI or any of that desktop stuff that lets Linux auto-discover our hardware
- we need to tell Linux the addresses and configurations for all of our CPU's fancy on-chip peripherals, and which kernel modules to load for each of them.

# busy box
- once Linux has finished initializing, it runs init. Our init program will likely want to run some shell scripts. 
  Those scripts might touch or echo or cat things. 
- It looks like we're going to need to put a lot of userspace software on our root filesystem just to get things to boot. 
  Now imagine we want to actually login(getty), list a directory(ls), configure a network(ifconfig), or edit a text file(vi)
- rather than compiling all of these separately, BusyBox collects small, 
  light-weight versions of these programs (plus hundreds more) into a single source tree that we can compile and link into a single binary executable.	
- BusyBox configuration is obvious and uses the same Kconfig-based system that Linux and U-Boot use.
 You simply tell it which packages (and options) you wish to build the binary image with.

# root filesystems
- Linux requires a root filesystem, it needs to know where the root filesystem is and what filesystem format it uses, 
  and this parameter is part of its boot arguments

# YOCTO & Buildroot	
- there's really no reason to hand-configure and hand-compile all of that stuff individually, 
  instead, everyone uses build systems, Yocto and Buildroot, to automatically fetch and compile a full toolchain,
    U-boot, Linux kernel, busybox, plus other packages you may wish.
https://jaycarlson.net/embedded-linux/#
=======================================
- lots of device drivers
- network and filesystem support
- memory management
- interprocess communication
- portable   
- open source/ free

Linux Kernel:
- memory management
- Scheduler task management
- filesystem layer and drivers
- device drivers + driver frameworks
- low level architecture specific code
- network stack
- device trees (hardware description) on some architectures, written in a device tree specific language

Roottfs, root file system:
- flash contents
	- Bootloader
	- kernel
	- root filesystem

system call:
- the kernel offers an API library of functions to the user-space programs, those libraries are available through the GNU C library

On Linux the memory is divided in two parts kernel and user space and they communicate through system calls
======================================

A standard GNU toolchain consists of three main components:
- Binutils: a set of binary utilities including the assembler and the linker
- GNU Compiler Collection (GCC)
- C library: A standardized application program interface(API) based on the POSIX specifiction, which is the main interface to the operating system kernel for applications

# building a toolchian using cresstool-NG
- use ./ct-ng list-samples to generate the list
- BeagleBone Black, TI AM335x SoC, which contains an ARM Cortex A8 core and a VFPv3 floating point unit
- the closest sample is arm-cortex_a8-linux-gnueabi
- ./ct-ng show-arm-cortex_a8-linux-gnueabi
- ./ct=ng build

- the toolchain sysroot is a directory which contains subdirectories for libraries, header files, and other configuration files.
- it can be set when the toolchian is configured through --with-sysroot=, or --sysroot=
- you can see the location of the default sysroot by using -print-sysroot:
	- arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot
- subdirectories in sysroot:
	- lib, contains the shared objects for the C library and the dynamic linmker/loader, ld-linux		
	- usr/lib, the static library archive files for the C library, and any other libraries that may be installed subsequently
	- usr/include, contains the headers for all the libraries
	- use/share, used for localization and internationalization
	- sbin, provides the ldconfig utility, used to optimize library loading paths
	
- other tools in the toolchain
	- addr2line, ar, as, g++, gcc ...

- the components of the C library
	- libc, the main C library that contains the well-known POSIX functions such as printf, open , close, read, write and so on
	- libm, contains maths functions such as cos, exp and log
	- libpthread, contains all the POSIX thread functions with names beginning with pthread_
	- librt, has the real-time extensions to POSIX, including shared memory and asynchronous I/O
* the first one, libc, is always linked in but the others have to be explicitly linked with the -l option. The parameter to -l is the library name with lib stripped off. For example, a program that calculates a sine function by calling sin() would be linked with libm using -lm
* arm-cortex_a8-linux-gnueabihf-gcc myprog.c -o myprog -lm
* you can verify which libraries have been linked in this or any other program by using the readelf command
* arm-cortex_a8-linux-gnueabihf -a myprog | grep "Shared library"
* Shared libraries need a runtime linker, which you can expose using:
* arm-cortex_a8-linux-gnueabihf-readelf -a myprog | grep "program interpreter"

# linking with libraries, static and dynamic linking
- any application you write for Linux, whether it be in C or C++, will be linked with the C library libc. This is so fundamental that you don't even have to tell gcc or g++ to do it because it always links libc. Other libraries that you may want to link with have to be explicitly named through the =l option
- the library code can be linked in two different ways
	- statically, meaning that all the library functions your application calls and their dependencies are pulled from the library archive and bound into your executable
	- dynamically, meaning that references to the library files and functions in those files are generated in the code but the actual linking is done dynamically at runtime.

## static libraries
- static linking is useful in a few circumstances
	- if you are building a small system which consists of onlu BusyBox and some scipt files,
   it is simpler to link BusyBox statically and avoid having to cpoy the runtime library files and linker
	- it will also be smaller becuase you only link in the code that your application uses rather than supplying the entire C library. 
	- static linking is also useful if you need to run a program before the filesystem that holds the runtime libraries is available
- you tell to link all the libraies statcially by addiung - static to the command line
	- arm-cortex_a8-linux-gnueabihf-gcc -static helloworld.c -o helloworld-static
- you will note that the size of the binary increases dramatically
- static linking pulls code from a library archive, usually named lib[name].a

- creating a static library is as simple as creating an archive of object files using the ar command. 
	- if i have two source files named test1.c test2.c and i want to create a static library named libtest.a
		- arm-cortex_a8-linux-gnueabihf-gcc -c test1.c
		- arm-cortex_a8-linux-gnueabihf-gcc -c test2.c
		- arm-cortex_a8-linux-gnueabihf-ar rc libtest.a test1.o test2.o
		- then I could link libtest into my helloworld program, using
			- arm-cortex_a8-linux-gnueabihf-gcc helloworld.c -ltest \ -L ../libs -I ../libs -o helloworld

## shared libraries
- a more common way to deploy libraries is as shared objects that are linked at runtime, 
  which makes more efficient use of storage and system memory, since only one copy of the code needs to be loaded
- it also makes it easy yo update the library files without having to re-link all the programs that use them
- The object code for a shared library must be position-independent, so that the runtime linker is free to locate it in memory at the next free address.
	- to do this, add the -fPIC parameter to gcc, and then link it using the -shared option
		- arm-cortex_a8-linux-gnueabihf-gcc -fPIC -c test1.c
		- arm-cortex_a8-linux-gnueabihf-gcc -fPIC -c test2.c
		- arm-cortex_a8-linux-gnueabihf-gcc -shared -o libtest.so test1.o test2.0
	- this creates the shared library, libtest.so
	- to link an application with this library, you add -ltest, exactly as in the static case memtioned in the preceding section, 
    but this time the code is not included in the executable. Instead, there is a reference to the library that the runtime linker will have to resolve.
		- arm-cortex_a8-linux-gnueabihf-gcc helloworld.c -ltest \ -L ../libs -I ../libs -o helloworld
	- the runtime linker for this program is /lib/ld-linux-armhf.so.3 which must be present in the target's filesystem.
	- the linker will look for libtest.so in the default search path: /lib and /usr/lib
	- if you want it to look libraries in other directories as well, you can place a colon-separated list of paths in the shell variable LD_LIBRARY_PATH:
		- # export LD_LIBRARY_PATH = /opt/lib:/opt/usr/lib

# understanding shared library version numbers
- one of the benefits of shared libraries is that they can be updated independently of the programs that use them.
- library updates are of two types
	- those that fix bugs or add new functions in a backwards-compatible way
	- those that break compatibility with existing applications
	- GNU/Linux has a versioning scheme to handle both these cases

- each library has a release version and an interface number
	- directory listing of <sysroot>/usr/lib/libjpeg*
		- libjpeg.a, this is the library archive used for static linking
		- libjpeg.so, this is a symbolic link, used for dynamic linking
		- libjpeg.so.8, this is a symbolic link, used when loading the library at runtime
		- libjpeg.so.8.0.2, this si the actual shared library, used at both compile time and runtime
		* the first two are only needed on the host computerfor building
		* the last two are needed on the target at runtime

# the art of cross compiling
- build systems
	- makefiles
	- The GNU build system, Autotools
	- CMake
- put the toolchian prefix in the make variable CORSS_COMPILE
	- make CROSS_COMPILE = arm-cortex_a8-linux-gnueabihg-
	- 1. export CROSS_COMPILE = arm-cortex_a8-linux-gnueabihg-
		2. make	
- the name Autotools refers to a group of tools that are used as the build system in many open source projects
	- GNU Autocong
	- GNU Automake
	- GNU Libtool
	- Gnulib
	* the role of Autotools is to smotth over the differences between the many different types of systems that the package may be compiled for, accounting for different versions of compilers, different versions of libraries, different locations of header files, and dependencies with other packages.
	* packages that use Autotools come with a script named configure that checks dependencies and generates makefiles according to twhat it finds.
	* the configure script may also give you the opportunity to enable or disable certain features. 
	* you can find the options on offer by running ./configure --help
	- to configure, build, and install a package for the native operating system, you would typically run the following three commands
		- ./configure
		- make
		- sudo make install
	- you can influence the behavior of the configure script by setting these shell variables
		- CC: the C compiler command
		- CFLags: additiona; C compiler flags
		- LDFLAGS: additional linker flags
			- for example, if you have libraries in a non-standard direcrotry <lib dir>, you would add it to the library search path by adding -L<lib dir>
		- LIBS: contains a lost of additional libraries to pass to the linker, for instance, -lm for the math library
		- CPPFLAGS: contains C/C++ preprocessor flags
			- for example, you would add -I<include dir> to search for headers in a non-standard directory <include dir>
		- CPP: the C preprocessor to use
		* sometime it is sufficient to set only the CC variable
		* CC= arm-cortex_a8-linux-gnueabihf-gcc ./configure
		- Autotools understands three different types of machines that may be involved when compiling a package
			- Build, is the computere that buildds the package, which defaults to the current machine.
			- Host, is the computer the program will run on; for a native compile, this is left blank and it defaults to be the same computer as build. When you are cross compiling, set it to be the tuple of your toolchain.
			- Target, is the computer the program will generate code for, you would set this when building a cross compuleer, for example.
		- to cross compile
			- $ CC=arm-cortex_a8-linux-gnueeabiihg-gcc \
					./confiigure --host=arm-cortex_a8-linux-gnueabihf
# bootloaders
- in embedded linux system, the bootloader hass two main jobs: initialize the system to a basic level and to loadd the kerneel
- first, a power-on or a reset
- the DRAM controller would not have been set up, so the main mery would not be accessible, 
  so storeage acesed via NAND flash controller , MMC controlers, and so on, would also not be usable.
*	DRAM controller, any integrated circuit having circuitry integrated thereon or contained thereon 
  that is capable through an interface of transmitting and/or receiving data from a DRAM
- typically, the only resources operational at the beginning are a single CPU core and some on-chip static memory.
- as a result, system bootstrap consists of several phases of code, each bringing more of the system into operation.
- the final act of the bootloader is to load the kernel into RAM and create an execution environment for it.
- the details of the interface between the kernel and the bootloader are architecture-specific, but in each case it has to do two things
	- botloader hass to pas a pointer to a structure containing informatiion about the hardware configuration
	- it has to pass a pointer to the kernel command line
- a subsidiary job of the botloadere is to provide a maintenance mode for updating bot configurations, 
  loading new bot images into memory, and, running diagnostics.
- the bootloader code runing in NOR flash memory can initialize the DRAM controler, so that the main memory, the DRAM,
  becomes available and then it copies itself into the DRAM. Once fuly operational, 
  the bootloader can load the kernel from flash memory into DRAM and transfer control to it.
* the above is for a simple linearly addressabe sotrage medium like NOR flash
* now, the boot sequencee becomes a complex, multi-stage procedure, the details are very specific to each SoC, but they generaly follow each of he folowing phases
# phase 1 ROM code

===
# computer architecture
- trends
  - intergated circuits improves in
    - density, how many transistors and wires can be placed in a fixed area on a silicon chip
    - speed, how quickly basic logic gates and memory devices operate
    - area, the physical size of the largest integrated circuit can be fabricated
    - the number of transistors can be fabricated on a silicon chip
    - transisors ssped -> the delay of a basic logic gate
- a number of metrics
  - MIPS, millions of instructions per second
  - CPI, cycles per instructions
  - IPC, instuctions executedd per cycle
  - benchmark suites
    - geometric mean and arithmetic mean  
- linker, join multiple machine lnaguage programas into a single executaable file
- width of address, 32bit and 64bit limits the amount of memory it cna use


# Unix, 1980
- system five, AT&T
- BSD, Berkley

# standards
POSIX, Porttable Operating System Interface for uniX
SUSm Single Unix Specification

# system calls
- processes
- files
- networking sockets
- signals, OS to processes
- inter-process communication
- terminals
- threads
- I/O devices

# read system call in C
- ssize_t read(int fd, void *buf, size_t count);

# prcoess:
- address space
  kernel code
  stack, starts empty, grows automatically
  heap, explicitly allocated during execution
    mmap, memory map pages to the process address space
    munmap, memory unmap pages from the process address space
      - why do munmap,
        1. heap would run out for this program
        2. other programs cant use that space in RAM.
           however, with virtual memory, it will get sawped to hard disk
      - eg, address = mmap(5000)
          # allocates 5000 bytes, address decides by the OS
          # the OS needs to find a space that have 5000 bytes
          # a page, in chunks, usually 4k bytes
          # so the OS probably allocates a bit more
          # do stuff with memory at address
          munmap(address)
      - garbage collection
        up to the interuptor, keep track of the object, if no more reference
  uninitialized data, global var,   
  initialized data, global var, exec file specifies the space and initialized value
  code
- user ids
  privileges, system calls might fail
  /etc/passwd, user accounts
  seteuid, sys call, sets effective user id
  setuid, sets real, effective and saved user id
  eg: pid 1(init), user 0
              |   fork(), exec()
      pid 2(login), user 0
              |   fork(), setuid(), exec()
      pid 3(shell), user 1780
  user groups: /etc/group
  each file and directory, rwx(user) rwx(group) rwx(other)
  read: can read bytes of files
  write: can add/remove/rename files
  execute: can use in file paths
    /adams/taft/garfield/esenhower,
    taft has to have x permission to use this path in a sys call

- file descriprors
- environment
- current and root directory

# fork(), create a new process
if fork() == 0:
  ... // new (child) process
else:
  // for parent process fork() would return the process ID of the child
- copy on write, make fork() cheap, 
  doesn't need to copy the entire address space in RAM, 
  only when first write happens

# exec system call
- repalces the existing program in a process with a new program
- the entire old address space would get discarded

# in unix, to start a new program
1. fork the existing process
2. and call exec
  if fork() == 0:
    ... // new (child) process
    exec('/games/pong')
  else:
    ... // original (parent) process
- when unix boots, init process, pid 1
- _exit, terminate the precess
  _exit(0), 0 is the exit code, tells other programs what happened, why did it exit
  0 indicates the process terminated noramlly
  the parent reads the exit code, wait(pid of the child process) system call
  eg,
  pid = fork();
  if pid == 0:
    ... // new (child) process
    exec('/games/pong')
  else:
    ... // original (parent) process
    code = wait(pid)
    // the parent process enters block state until the child process terminates

- open
  open/create a file and return a file descriptor
- close
  release file descriptor
- read
  copy bytes from a file to memory
- write
  copy bytes of memory to a file
eg: 
  fd = open('/alice/time')
  write(f, 'bla bla')
  // data = read(fd)
  close(fd)

eg:
  fd = open('/alice/time')
  data = read(fd)
  while len(data) != 0:
    print(data)
    data = read(f)
  close(fd)
- fd has a marker, byte 0, marker, last byte
  two fd, two makrer, doing read and write
- truncate(), sys call, shrink files and expand files
- lseek(), sys call, move the marker to which byte
- descriptor -> description( marker info) -> buffer -> file on disk
- read and write are not atomic, might happen at the same time

- umask, get/set default permissions for new files/directories
eg:
  oldmask = umask(newmask)
- chmod, change mode, set permissions of an existing file/directory
eg:
  chmod('/alice/time', mask)
- chown, change owner, set owner of an existing file/directory
eg:
  chown('/alice/time', user, group)

- each file and directory in a partition is known by a unique inode number
- root diectory always has inode 2
- link, add directory entry
- unlink, remove directory entry
  link('/alice/tim', '/ben/kkk')
  unlink('/alice/tim')

- getdents, get directory entries
  fd = open('/alice')
  entries = getdents(fd)
  while len(entries) != 0:
    print(entries)
    entries = getdents(fd)
  close(fd)

- mount, attach partition to the unified file system
- umount, detach partition from the unified file system
eg:
  mount(partition1, '/alice/tim')
  umount('/alice/tim')

- /, when boot, / mount to one partition
- create a directory and then mount
- absolute path vs relative path
- chdir, change cwd, the current working directory

- partition composed of blocks
- device file, /dev, directory of device files
  block device buffers backed by storage
  character device buffers not backed by storage data in and out in sequence
  pseudo-device files
    /dev/zero, returns zeroed bytes
    /dev/random, returns random data
    /dev/null, discards data, write to it, returns no bytes at all
eg:
  bf = open('/dev/sda1')
  cf = open('/dev/lp0')
  lseek(bf, 100)
  bdata = read(bf)
  cdata = read(cf)

- mknod, make node, create a regular file, device filem, or named pipe
  mknod('/ryan/kim,', BLOCK, deviceNum)
  mknod('/ryan/erin,', CHR, deviceNum)
  mknod('/ryan/tine,', FIFO) // named pipe

- pipe(), creates a new anonymous pipe and returns two fds
- pipe(), for one way communication related processes
- named pipe, for one way communication unrelated processes
  
eg: 
  fds = pipe()
  fd1 = fds[0] // read
  fd2 = fds[1] // write
  // create a pipe and fork, child and parent communication

- memory-mapped files
eg:
  fd = open('/brad/mike')
  address = mmap(500,fd,200)
  ... // reading/writing the alocated memory reads/writes the file
  munmap(address)
  close(fd)

- signals, sent by kernel or kill system call
  SIGSEGV, signal segamentaion fault
    memory error, process tries to use memory not in its address space
  SIGFPE, signal floating point error
  SIGSTOP, signal stop
  SIGCONT, signal continue
- kill(), send a signal to a process
- signal(), set a signal to be handled, ignored or triggered its default action
eg:
  kill(35, SIGSTOP)
  signal(func, SIGFPE)

# SRAM vs DRAM
- SRAM, doesnt need to be refreshed, usually used in cache 
  - faster, less power
  - less memory capacity, high cost, complex design
- DRAM, capacitors, gradually discharge energy, periodic refresh of power, usually used in main memory
  - slower, high power consumption, cheaper

# RAM
- addressable by the CPU
- volatile
- faster than storage
- stores cide and data of running programs

# memory mapped I/O
- RAM
- devices register

# polling
- code periodically checks device registers to see if the device needs the CPU to do something

# interrupt
- signal from device causes CPU to run interrupt handler code

# kernel
- the kernel is a computer program that manages input/output requests from SW and 
  translates them into data processing instructions for the cpu and other components
- under /boot
- uname -a
- /lib/modules
- ls mod

# OS
- manages the hardware and running programs
  - load and manage processes
  - provides interfaces to HW via system calls
  - provides a file system
  - provides a user interface
- device driver
  - OS plug-in module for controller a particular device

# struct in C 
- struct Vector2D {
    float x;
    float y;
  }
  typedef struct Vector2D Vector2D;
- typedef struct Vector2D {
    float x;
    float y;
  }Vector2D;

# device tree
- ePAPR, embedded power architecture platform requirements
- a device tree is a tree data structure with nodes that describe the physical devices in a system
- An ePAPR-compliant device tree describes device information in a system that cannot be dynamically detected by a client program

- .dts
  - a tree data structure describing the HW is writtern by a developer in a Device Treee Source file
- .dtc
  - device tree compiler
- .dtb
  - .dts gets compiled by .dtc into a device tree blob representation
  - accurately describes the HW platform in an OS-agnostic way

- tree of nodes
  - nodes with properties
  - a node, a device or IP block
  - properties, device characteristics
  - dtc only does syntax checking

# on ARM, DTS, device tree source
- DTS are located arch/arm/boot/dts
- .dts files for board-level definitions
- .dtsi files for included files, generally containning SoC-level definitions
- DTC, device tree compiler, compiles the source into a binary form
  - source code located in scriptes/dtc
- DTB, device tree blob, proced by the compiler
  - the binary that get loaded by the bootloader and parsed by the kernel at boot time
- arch/arm/boot/dts/Makefile, lists which DTBs should be generated at build time

# a simple example, device tree side
- compatible
  - defines the programming model for the device
  - allows the OS to identify the corresponding device driver
  - compatible = "fsl,imx28-auart", "fsl,imx23-auart";
- reg
  - address and length of the register area
  - reg = <0x8006a00 0x2000>;
- interrupts
  - interrupt number
  - interrupts = <112>;
- dmas, dma-names
  - DMA engine and channels with names
  - dmas = <dma_apbx 8>, <dma_apbx 9>,
  - dma-names = "rx", "tx";
- clocks
  - regerence to the clock
  - clocks = <&clks 45>;
- status
  - the device is not enabled
  - status = "disabled";

# a simple example, driver side
= the compatible string used to bind a device with the driver
- static struct of_device_id mxs_auart_dt_idsp[] = {
    {
      .compatible = :fsi,imx28-auart",
      .data = &mxs_auart_devtyoe[IMX28_AUART]
    },{
      .compatible = :fsi,imx28-auart",
      .data = &mxs_auart_devtyoe[IMX28_AUART]
    },{/*sentinel*/}
  } ;
  MODULE_DEVICE_TABLE(of, mxs_auart_dt_ids);
  ...
  static struct platform_driver mxs_auart_driver = {
    .probe = mxs_auart_probe,
    .remove = mxs_auart_remove,
    .driver = {
      .name = "mxs-auart",
      .of_match_table = mxs_auart_dt_id
    }
  };
https://www.youtube.com/watch?v=m_NyYEBxfn8&ab_channel=TheLinuxFoundation

# SPI NOR Flash
- a type of nonvolatile memory that can be electrucally erased and reprogrammed
- flash memory type
  - NOR Flash
    - data can be read and written byte per byte
    - low latency, good for data storage and direct code execution
    - communication via serial peripheral interface, SPI
  - NAND Flash
    - size of page is being read and written
  - eMMC Flash, does read OR write, serial, NAND flash with built-in controller
  - UFS, does read AND write, parallel

- SPI
  - synchronous serial communication
  - operates in master - slave setup
    - master provides the clock signal and initiates all communications
  - multiple slaves can be connected to one master
  - SCLK, clock
  - CS, chip select
  - MOSI, master out slave in
  - MISO, master in slave out

# cache
- faster access to frequently used blocks of data
- less important data is still accessible, stored in chaeper memory
- CPU <- cache -> main memory
  browser <- cache -> internet
- sits between CPU core and DRAM main memory
- usually SRAM on process chip

- RAM, reuqires constant electrical power to store data
  - RAM stored on the motherboard in modules that are called DIMMs, Dual Inline Memory Module
  - DRAM, dynamic RAM, contains capacitors, needs constant refresh with electricity, operates Asynchronously with the system clock
  - SDRAM, synchronous dynamic RAM, operates synchronously with the system clock, better controlled timing.
  - SRAM, static RAM, high performance, does not need to constant refresh
  - flash memory, non volatile, limited write cycles
- the term 64/32 bit data path, 8/4 byte wide bus refers to the number of bits of data that are transferred in one clock cycle

- DDR, double data rate SDRAM
  - sends double the amount of data in each clock signal
  - non DDR, single data rate RAM
- ECC, eerror correcting code, detects if the data was correctly processed by the memory module

- CPU read
  - cache hit
    - the cache contains that block CPU wants to read
    - access is fast
  - cache miss
    - the cache must get the block from the main memory
    - only then can cache deliver block to CPU
    - access is bad
  - evication/replacement
    - new block is loaded into cache
    - some other block is removed
    - furure requests can be served directly from the cache
    - after a cache miss, evict a block, least recently used
  - cache locality
    - most programs exhibit localotity
    - temporal locality, used bytes
    - spatial locality, nearby used bytes
- CPU write
  - wrtie hit
    - write through
      - cache immediately writes modified block to memory
    - write back
      - cache waits, writes block to memory when the block is evicted
      - cache needs a "dirty bit" to indicate if it is modified or not
  - write miss
    - write allocate
      - read block into the cache, update the copy in the cache
      - set "dirty bit"
      - good if there are more writes to this block
    - write no allocate 
      - send the write on through to memory, do not load block into cache

- cache blocks, 8 bytes
- address, 32 bits
- block address ends in 3 bits 000, alignment
  - address of byte within the block, also called block offset
- a cache line is 8 bytes in size, although it has additional stuff 
  - 29 bits(32-3) + valid bit + dirty bit + 8 bytes of data

- traditional memory, byte addressable
  - address size, n bits -> 2^n bits stored
- associative memory
  - key -> value
  - key can be any size, e.g. 29 bits
  - small number of lines, key + value
  - for cache
    - key, address of block, also called tag
    - value, data
- example:
  - a 32-bit addess input 
  - extract 23-bit "tag" and 6-bit "block offset"
  - send "tag" to associative memory
  - if match:
    - retrieve 64 bytes data block from associative memory
    - use offset to extract the desired byte and send to CPU
  - if no match:
    - select a block to evict, need more bits to implement least recently used line of memory
    - is it dirty, wirrte back to memory
    - send "tag" to main memory, get 64 bytes back
    - update cache line, tag(key), data, dirty bit, vaild bit
    - extract the desired byte

- fully associative cache, not good in large scale
  - any block can go into any cache line
- direct-mapped cache
  - each block can go into only one cache line
  - to avoid associative lookup
  - all we have to do is to retrieve the cache line and check to see if it contains the right block
  - tag + index + offset into block
    - 512 cache lines are indexed by 9-bit of index
  - operation:
    - from the address, extract tag, index and offset
    - use the index to find the correct line
      - 9-bit -> address into cache memory
    - read out this line and compare the tag from the address to the tag in the cache line
      - same -> cache hit
      - different -> cache miss
    - use the offset to extract the desired byte
  - potential address for cache line 2
    - 0 ... 00 00(17-bit tag) + 00 00 00 01 0(9-bit index) + offset, block 2
    - 0 ... 00 01(17-bit tag) + 00 00 00 01 0(9-bit index) + offset, block 514
    - 0 ... 00 10(17-bit tag) + 00 00 00 01 0(9-bit index) + offset, block 1026
    - 0 ... 00 11(17-bit tag) + 00 00 00 01 0(9-bit index) + offsetm block 1538
  - cache thrashes, a working set occurs in both potential blocks, would affect performance
    - have a cache line holding multiple blocks

- cache misses
  - compulsory miss, cold cache
    - nothing in cache when program begins
  - capacity miss
    - cache is too small, can not contain the entire working set
  - conflict miss
    - plenty of room in cache, but 2 blocks in working set, can not both be in the cache together

# data aligmment
- byte data
  - can go at any address
- halfword data
  - must be "halfword aligned"
  - addresses must be even numbers
- word data
  - must be "word aligned"
  - addresses must be divisible by 4

# spin lock
- struct spinlock
  {
    uint locked;
    char *name;
    struct cpu *cpu;
  } 
- acquire(ptr)
  - if *locked == 0, *lock =1
    - else loop and try agian
  - Atomic SWAP instruction, AMOSWAP
    - not interruption between retrive a value and setting a value
    - writing one to *locked, and retrive the previous value.
      - if the previous value is not zero, then loop back to write
  - a fence instruction to prevent C compiler andd the processor to move loads and stores
    - to ensure that the critical section s memeory references happen strictly after the lock is acquired
- release(ptr)
  - *locked = 0;
- init_lock(ptr)

- spinlocks should not be held for long
  - spinning wastes cycles
  - use sleep() and wakeup()
- used to protect shared data
  - acquire()
    "critial section"
  - release()

========
driver_dev

* device drivers
- make a particular piece of hardware respond to a well-defined internal programming interface
- they hide completely the details of how the device works
- mapping the set of standardized calls that are independent of the spcific driver to device-specific operations that act on real hardware 

* a device driver emphasizes on providing mechanism, not policy
- "what capabilities are to be provided" (mechanism)
- "how those capavilitiess can be used" (policy)

* splitting the kernel
- process management
  - create and destroy processes
  - input and output for processes
  - communication among processses
  - scheduler, how processes share the CPU
- memory management
  - virtual address space
- filesystems
- device control
- networking
  - incoming packets aree asynchronous events
  - collect, identify and dispatch packets before any process

* module
- each piece of code that can be added to the kernel at runtime
- each module is made u of object code 
  - not linked into a pcomplete executable
  - that can be dynamically linked to the running kernel by insmod program aand unlinked by the rmmod program

* character devices
  - a char device is one that can be accessed as a stream of bytes (like a file)
  - such a driver usually implements at least the open, close, read and write system calls
  - the text console (/dev/console) and the serial ports (/dev/ttyS0) are examples of char devices, 
    as they are weell represented by the stream abstraction
  - you can always move back and forth in thee regular file
  - whereas most char devices are data channels, you can only acceess sequentially
    - frame grabbers using mmap aand lseek

* block devices
  - block devices are accessed by filesystem nodes in the /dev directory
  - it can host a filesystem
* network interfaces
  - exchange data with other hosts
  - a network interface is in charge of sending and receiving data packets,
    - driven by the network subsystem of the kernel
    - without knowing how individual tansactions map to the actual packet being transmitted
    
* kernel module
- pieces of code that can be loaded and unloaded into the kernel upon deemand
- they extend the functionality of the kernel without the need to reboot the system
- lsmod, gets its information by reading the file/proc/module
- kernel modules must have at least two functions
  - a start/initialization function,called when the module is insmod ed into the kernel
    - init_module()
  - an end/cleanup function, called before it is rmmod ed
    - cleanup_module()
  - include linux/module.h

- printk()
  - a logging mechanism for the kernel
  - is used to log infomation or give warnings
  - /var/log/messages (file names varies between Linux distribution)

* kernel modules versus applications
  - for applications
    - it can cal functions it doesn't define
    - the linking stage resolves external references using the appropriate library of functions
      - eg, printf is defined in libc
  - a kernel module
    - has to be careful with releasing resources and cleaning up
    - is only linked to the kernel
    - the only functions it can call are the ones exported by the kernel
    - there are no libraries to link to
      - eg, printk()
    - <stdarg.h> being the only exception header file
      - it is actually part of the kernel itself
  - a kernel module runs in kernel space
  - an application runs in user space
    - different privilege levels
    - their own address space in memory
  - applications are laid out in virtual memory with a very large stack area
    - the stack is used to hold the function call history and all automatic variables created by the currently active funtion
  - the kernel module has very limited stack

- vermagic.o is used to check the processor-specific configuration
  - when build, it links the kernel module against vermagic.o from the current kernel tree

- initialization functions should be declared static, 
  - since they are not meaent to be visible otside the specific file
  - without module_init(), the init function would never be called

- module parameters
  - insmod hello howmany=10 whom="mom"
  - module_param(howmany,int,S_IRUGO);
  - module_param(whom,charp,S_IRUGO);
  - types supported for module parameters:
    - bool
    - invbool, the invbool type inverts the value of a bool
    - charp, a char pointer value
    - int, long, short, uint, ulong, ushort
  - module_param_array(name,type,num,perm);
    - perm is the usual permission value, determines who can acceess thee representation of the module parameter in sysfs

* kernel-space drivers and user-space drivers
- the advantages of user-space drivers are:
  - the full C library can be linked in
  - a conventioanl debugger on the driver code, instead of deugging a running kernel
  - user memory is swappable
- drawbacks for user-space driver:
  - interrupts are not available in user space
  - direct access to memory is possible only by mmapping /dev/mem, only a privileged user can do that
  - access to I/O ports is avaiable only after calling ioperm or iopl
  - response time is slower

* scull, simple character utility for loading localities
  - a char driver

* understanding the structure of a Linux kernel device driver
- providing an infrastructure to write and run devicee driveers is part of an OS's kernel responsibility
- there are a few kernel APIs that could be used to export an interface to userspace in the filesystem, /dev, /sys
- device nodes
  - one of the interfaces that could be used,
  - where files are exporteed to users in /dev in the for of char or block device files
    - char type, a device exchange bytes or stream of bytes 
    - block type, specific amount gated by the block
- implement a char driver
  1. allocate the device number(major/minor)
    - register_chrdev_region()
    - alloc_chrdev_region()
  2. implement the file operation(open, read, write, ioctl, etc)
  3. register the char driver in the kernel with cdev_init() and cdev_add()
  - major device number,
    - tells which driver it uses
  - minor device number,
    - tells which device exactly used of that device type

cat /proc/devices
mknod /dev/lede c 244 0

- insmod used to load a module
- modprob, also looks for any dependency

* permission denied for echo 1 > /dev/led
- solution: sudo chmod 666 /dev/led

https://www.youtube.com/watch?v=pIUTaMKq0Xc&ab_channel=TheLinuxFoundation

========
- git init
- git status
- git add file.js
  - git add . // add all changes
- git commit  -m "adding a new file"

- git log
  - history of commits

- git check out xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

* git branch new_branch
- git checkout new_branch

* merge to the master branche
- git branch // ist all the branches
- git merge new_branch

* .gitignore

- get add . // stage files
- git reset . // un stage files
- git reset -- hard // un stage files and delete all files

===
* screen
- Ctrl + a
- tick/tilda key
- tick+tick to toggle window
- Ctrl + a A to rename the current window

- split
  - Ctrl + tab to swtich the input focus to the next region
  - Ctrl + a and Q to close all regions but the current one
  - Ctrl + a and X to close the current region

- detach
  - Ctrl + a and d
- reattach
  - screen -r
  - screen -ls
    - screen -r 10835

===
* watch
- or
  - while true; do clear; lsusb; sleep 2; done

========
# linux kernel device driver
- device drivers are just abstractions to a piece of hardware
- on Unix based systems, a file is the most common abstraction to communicate with a device
  - file(user space) <-> device driver(kernel space) <-> hardware device 

========
# BIOS
- BIOS is tied to the MBR, master boot record systems, which limits the disk size to 2 TB
- slower boot time
- less secure boot

# UEFI
- UEFI uses the GPT, GUID partition table
- removing size consttanints 
- faster boot time
- secure boot

- GRUB2, boot lodaer

======
- lazy:
  - copy-on-write
  - writing buffering
  - zero-filled in demand
  - demand paging
  - memory mapped files

- if a process needs more memory to fit exec(), it could use malloc() and sbrk()
- every process has its own unique fd

OS purposes:
- abstract hardware for convenience and portability
- multiplex the hardware among many applications
- isolation applications in order to contain bugs
- allow sharing among coopeerating applications
- control sharing for security
- dont get in the way og high performance
- support a wide range of applications

OS orgnization:
 user:VI,CC:C compilor,SH:shell
 kernel:FS:file system, processes,memory allocation, access control
CPU
RAM 
DISK
NET

API-kernel(system call)
- open file:
  fileDescriptor = open("fileName",1)
  fileDescriptor,fd, so the system uses it as a handle to refer to this open file
- write file:
  write(fd,"hello\n",6)
  a pointor to a buffer of characters "hello\n"
- fork is the system call that create a new process:
  pid = fork();
  pid, process indentifier

efficient-abstract
powerful-simple API
flexible-secure

system calls are the interface to the services that the OS provides

OS xv6
microprocessor RICS-V
QEMU machine simtlator

xv6 has no ps command, but, if you type Ctrl-p, the kernel will print information about each process. 
If you try it now, you'll see two lines: one for init, and one for sh.

To quit qemu type: Ctrl-a x (press Ctrl and a at the same time, followed by x).

---
- C uses manual memory mangagement, not garbage collection
  - explicit malloc() and free(); direct access to memory

- endianness
  - 0x12345678
  - big-endian, 0x12, 0x34, 0x56, 0x78
  - small-endian, 0x78, 0x56, 0x34, 0x12
  - big-endian means it starts with the most significant byte
  - little-endian means it starts with the least significant byte

memory in C 
-Static memory
  - global variables
      variables declared outsided any functiion, and variablees declared with static
  - a signggle is stored, at a predefined and unchanging memory address
  - initialized to zero by default
-stack memory
  - local variables within functions. Destroyed after function exits
  - not initialized by default. will refleect whatever happened to be in that piece of memory
-Heap memory
  - users can control creation and destruction of these variables:
malloc() free()
      this can lead to memory leaks, use-after-free issues
  - not initialized by default. will refleect whatever happened to be in that piece of memory
---
pointers in C
a pointer is a 64bit integer whose value is an address in memory
every variable has an address. so every variable's pointer can be accessed
including a pointer to a pointer, and a pointeer to a pointer to a pointer...
a pointer can handle arithmetic with the operators ++,--,-,+

int x =5;
int* x_address = &x;
* x_adddress = 6; // use * operator to access the uderlying value
int x_value = * x_address; // this gives 6
int arr1[10]; // arrays are secretly pointers
int* arr2[20]; // array of pointers, making arr2 a pointer to a piointer
void* myPtr;
---
arrays in C
C arrays are contiguous blocks of memory holding a particular data type
the variable is the pointer to the beginning of the array

char myString[40]; // type of myString is char*
char* myArrayOfStrings[20]; // type of myArrayOfStrings is char**
int counting[5] ={1,2,3,4,5}; //type of counting is int*

int arr[4]={5,6,7,8};
these are all equivalent
arr[2]=50;
*(arr+2)=50;
2[arr]=50;
downsides:
users are allowed to access or modify illegal memory by accessing an array out of bounds. C provides no checking whatsoever.

int strlen(const char& str){
  int i;
  for(i =0;str[i] !=0; i++){
    return i;
  }
}

===
* unix interface
  - abstracts thee hardware resources
    - OS offers processes instead of CPU
    - OS offers exec() instead of memory
    - OS offers files instead of disk block
  - hardware supports for isolation
    - user/kernel mode
      - kernel, privileged instructions
        - set up page table, disabling clock, interrypts
      - user, unprivileged instructions, add, sub, branch, jr
    - virutal memory
      - page table, virtual addresses -> physical addresses
        - each process has its own page table, 
            - so it can only access to that physcial memory
            - memory isolation
  - entrying kernel
    - in xv6, ecall(n), n is the system call number
      - write(), in user space -> ecall -> sys_wrtite -> syscall in the kernel -> write 

* kernel, trusted computing base, TCB
  - kernel must have no bugs
  - kernel must treat processes as malicious
  - monolithic design
    - huge codes, more bugs
    - tight integrition, better performance
  - microkernel design
    - small, fewer bugs
    - less performance
    - consists of IPC, inter-process communication (message passing), VM, and mulitplexing for CPUs

  - pro.c ->gcc-> proc.s (RISC-V) ->assembler-> proc.o
    - take all .o link(ld) to kernel
    - kernel.asm
  - qemu
    - for(;;){
        read instruction
        decode instruction
        execute instruction
      } 
    - registers

page tables, virtual memory
- address spaces
- hardware for page table
  - memory management unit
    - read the mapping from memory and do the translate
    -       virtual address | physical adddress
            0xx1000         | 0x12345678
    - CPU -> virtual address -> MMU -> physical address -> memory
  - satp register in CPU tells where is the memory map in memory
    - when CPU switches between processes, it also switch satp register
  - every application has their own map
- 64 bit wide register, 2^64 possible address
  - per address X, too many
  - per page, 4KB, 4096 bytes
    - virtual address, 64
      - 25  | 27    | 12
        EXT | index |offset
      - supports 2^39 = 512 Gbyte used in RISC-V virtual memory
      - index used for page table
        - MMU takes index to the map and finds physical page number (PPN) in memory
        - PPN points to a 4KB (2^12 = 4096bits) page, offset indexs the page
    - physical address, 56
      - 44                        | 12      
        PPN, physical page number | offset  
      - supports 2^56 bits of physical memory
- page table structure
  - in RISC-V, there are 2^27 entries for the page table
    - 9 | 9 | 9 | 12
      L2|L1 | L0| offset
- translation look-aside buffer, TLB in the CPU
  - stores when doing page table loop up
  - cache of PTE 
  - [virtual address, physical aadress]
  - switch page -> flush TLB
- physical address
  - DRAM
  - i/o devices 0x0 -> 0x80000000

ISA, instruction set architecture
RICS-V, reduced instruction set 
x86-64, CISC, complex instruction set
ARM, RISC

* traps
- a trap is a synchronous interrupt triggered by an exception in a user process to execute functionality
- RISC-V CPU has:
  - 32 registers, including stack pointer register
  - program counter register
  - MODE
  - SATP, pointer to the page table
  - STVEC,
  - SEPC
  - SSCRATCH

- supervisor mode
  - R/W control register
  - use PTEs with PTE_U 

- Shell
  wrtie()
  ecall
  uservec -trampline       userset()
  usertrap()
  syscall()         usertrapret()
  sys_wrtie()

===
* KVM
- kernel-based vitrual machine

linux file structure
* man hier
* bin, essential executables
* sbin, system bin, essential executables for super user(root)
* boot, file needed to boot, kernel and bootloader
* dev, device files, interface with hardware or drivers
* etc, et cetera, editable configration file
* lib, shared code between binaries
* opt, optional, add-on software
* var, files which may change in size
* tmp, will not be perisited between reboot
* proc, not in disk, but in RAM
* home, user data
  - /bob
  - /alice
* usr, unix system resource
  - bin, sbin, lib
    - non essential installed binanaries
  - local
    - locally compiled

- $PATH, tell linux where to find executables
https://www.pathname.com/fhs/pub/fhs-2.3.pdf

===
AoC 2021 in TempleOS 
https://www.youtube.com/watch?v=nvldfkikveI&ab_channel=TsodingDaily

ls -l -h, use -h option together with -l, this will have the pitput in k,M,G for a better understanding

.../qemu-system-x86_64 -cdrom .../TempleOS.ISO
* x86_64 is a 64 bit version of the x86 instriuction set
* x86 is a family of instuction set architecture initially developed by Intel based on
Intel 8086 microprocessor and its 8088 variant
* cdrom, compact disc read only memory

.../qemu-system-x86_64 --help | more
* more is old utility
* less is more + more additional features

.../qemu-system-x86_64 -cdrom .../TempleOS.ISO -m 512
* if qemu-system-x86_64 is not able to read the bios.bin under /usr/share/qemu directory,
 then it will end up with an error ould not load PC bios.bin
* -L /usr/local/Cellar/qemu/6.1.0_1/share/qemu and this will allow
 the command qemu-system-x86_64 to look out for the bios.bin under the given directory.

 /Users/chenshen/Downloads/qemu/build/qemu-system-x86_64 -cdrom /Users/chenshen/Downloads/TempleOS.ISO  -m 512 -L /usr/local/Cellar/qemu/6.1.0_1/share/qemu
* when OS doesnt have GUI, use ctrl-a x to quit

 /Users/chenshen/Downloads/qemu/build/qemu-system-x86_64 -cdrom /Users/chenshen/Downloads/TempleOS.ISO  -m 512 -L /usr/local/Cellar/qemu/6.1.0_1/share/qemu -enable-kvm
* kvm, kernel-based virtual machine. This acceleration method won't work, kvm is the linux hypervisor implementation
* use accel=hvf instead

creat a hardrive for templeOS
/Users/chenshen/Downloads/qemu/build/qemu-img --help | more
/Users/chenshen/Downloads/qemu/build/qemu-img create templeOS.img 512M

 /Users/chenshen/Downloads/qemu/build/qemu-system-x86_64 -cdrom /Users/chenshen/Downloads/TempleOS.ISO  -m 512 -L /usr/local/Cellar/qemu/6.1.0_1/share/qemu -hda ./templeOS.img

boot from the image
/Users/chenshen/Downloads/qemu/build/qemu-system-x86_64 -m 512 -L /usr/local/Cellar/qemu/6.1.0_1/share/qemu -hda ./templeOS.img

#!/bin/sh, bourne shell compatible script
The first line tells the shell that if you execute the script directly (./run.sh; as opposed to /bin/sh runsh), 
it should use that program (/bin/sh in this case) to interpret it.
If the file that this script lives in is executable,
 the hash-bang (#!) tells the operating system what interpreter to use to run the script. 
 In this case it's /bin/sh, for example.

set -x, in shell script

print shell command before execute it

set -e, in shell script

if the return code of one command is not 0 and the caller doesnt check it, the shell script will exit.

chmod, changes the file mode bits of each given file according to mode
chmod +x on a file/ script, means you'll make it executable
* if its not executable, use sh run.sh to run it

next line, ctrl v + ctrl j

linux, mounting and unmounting a filesystem
- to begin interacting with the disk, we need to mount the filesystem to  a directory.
* why not just cd /dev/sdb (second disk), becuse /dev/sdb is not a directory
* to resolve this, we need to create a directory and then mount the file system of 
the external drive to this directory
* most OS actually do this for us automatically when we plug ina device like a USB drive.
* unmount the filesystem, using umount

example:
	sudo parted -l
	sudo mount /dev/sdb1 .../myUsb
	cd .../myUsb
	sudo umount /dev/sdb1 or sudo umount .../myUsb

permanently mount a disk
automatically load up when the computer boots, to do this, we need to modify /etc/fstab 
fstab contains a list of unique device IDs, their mount points, types of file system and so on
* blkid, for the storaghe block device IDs

how to run qemu:
1. setup a virtual disk
	- qemu-img create image.img 200M
	- it will create an image file thats about 200MB
2. run qemu
	- to emulate a legacy PC system, use qemu-system-i386
	- to emulate a more modern system, use qemu-system-x86_64
	- use -hda imagefile to tell qemu to use imagefile as the hard drive image, this should be the same virtual disk you defined with the qemu-img command
	- set -cdrom isofile to define the CD_ROM or DVD image file.
3. memory
	= set the amount of memory in the virtual machine with the -m size option
	- default 128MB
4. boot order
	- use -boot [options] to specify the order that qemu should look for bootable devices
	- for example, set -boot order=dc to tell QEMU to try the CDROM (d) first, then the hard drive (c)

hot to mount a QEMU virtual disk image:
- linux can mount QEMU's raw disk image format, assuming it knows where to find the start of the C drive partition on the virtual disk. a virtual disk can contain multiple paritions
- use linux fdisk program, with -l option will list the partitions on the virtual disk
		fdisk -l image.img
    output: 
						Disk image.img: 100 MiB, 104857600 bytes, 204800 sectors
						Units: sectors of 1 * 512 = 512 bytes
						Sector size (logical/physical): 512 bytes / 512 bytes
						I/O size (minimum/optimal): 512 bytes / 512 bytes
						Disklabel type: dos
						Disk identifier: 0x00000000

						Device     Boot Start    End Sectors  Size Id Type
						image.img1 *       63 204623  204561 99.9M  6 FAT16
		here the C drive is the first and only partition on the virtual drive, listed as image.img1.
		to determine the offset of the C drive, you need to know the starting sector of that partition. the ouput from fdisk shows this as 63
		to calcualte the offset, you also need to know the sector size. This virtual disk image has sectors of 512 bytes. 
		you can calculate the offset as the product oif the offset and the sector size: 63* 512 = 32256
- use this offset value to mount the virtual C drive from linux
	mkdir /temp/dos
	sudo mount -o loop, offset =32256 image.img /temp/dos
	ls /tmp/dos
	sudo umount /temp/dos
	* /tmp/dos is a temporary directory for DOS system


the main components of OS are
- kernel
  kernel is responsible for managing the communication between the softwaare, user level applications and the hardware, CPU, disk memory etc.
- process management
- file system
- memory management
- I/O management

two important region of a memory
- user space
  it is a region of memeory where normal user processes run, everything other than kernel
- kernel space
  it is a region of memory where code of kernel resides and executes.
  it is considered to be privileged part of a memeory invoked by system calls, it is also known as system space
 
 a program is a passive entity residing at secondray memory
 a process is an active entity resding in the main memory

 a process can go through following states in its lifecycle
 - new
 - ready
 - running
 - waiting
 - terrminated

pid, process id

fork() is a system call which is responsible for creating a copy of a current process
the current process is termed as parent process and the created process is termed as child process
- fork creates a copy of the memory of instructions and data of the calling process
- it returns in both process, in the original process, it returns the process id of the newly created process. in the newe process, it returns 0
- fd table is copied, parents have some file open, child sees the same

system call
its like a way by which any user level program ask for the services offered by a kernel
it acts as an interface between a process and the OS

PCB, process control block
a data structure which hold all information, attributes of a process

there are four section of a process
- stack, contains local variables, returns address
- heap, dynamically allocated memory via malloc, calloc, realloc
- data, contains global and static vaiables
- code or text, contains code, program counter and content of processor's register

malloc()
memory allocation
it reserves a block of memory of the specified number of bytes
it returns a pointer of void which can be casted into pointers of any form

calloc()
contiguous allocation
malloc() function allocates memory and leaves the memory uninitialized
calloc() function allocates memory and initializes all bits to zero

realloc()
if the dynamically allocated memory is insufficinet or more than required,
you can change the size of previously allocated memory using the realloc()
e.g ptr = realloc(ptr,x);
ptr is reallocated with a new size x

context switching
it is switching of a processor from one process/thread to antoehr

inode
it is a data structure which holds all the attributes of a file
like file type, permission, file size, time when last it is modified

thread
thread is a concurrent unit of execution within a process
a process can have multiple threads where each thread can perform a different task independently,
thus increasing the efficiency of a process.
a process always has one thread by default called main thread which is executed first
e.g 
- Word processor, a background thread may check spelling and grammar w
hile a foreground thread processes user input (keystrokes).
- Web server  Multiple threads allow for multiple requests to be served simultaneously,
 without having to service requests sequentially.

benifits of a thread
- responsiveness
  a process with thread are said to be more responsiveness than a process without thread 
  because even if one thread if blocked or waitting for some resources 
  the other thread still continue to function
- lighter,
   most of the resource of a process are shared by all its thread making it lighter
- thoughput
  it improves the throughput of a multithreaded application, mulitiprocessor environment
- economy
   creating and managing thread is much faster, 
   context switching is faster than performing same task for processes

disadvantages associated with thread
- robustness
  if any one thread is terminated abnormally, it leads to entire process termination
 
process
- is used for heavy task
- are less responsive than threads
- more robust than threads
- each process will have its own address space
- processes have less synchronization overhead since all have separate address space(memory)

thread
- are used for mall task, lightweight
- more responsive than process
- less robust
- threads are within a process thus share same address space(memory)
- Since they share same address space, synchronization is more overhead than process

scheduler
it is one of the compenonet of kernel responsible for s
cheduling that is deciding when to run which process 

mutex, 
is a locking mechanism which allows only one process to access the resource at a time

deadlock
a deadlock is a situation where two or more process or threads 
sharing the same resource are effectively preventing each other from accessing the resources
the conditions required for deadlock to happene
- mutual exclusion, mutex
- hold and wait
- no preemptyion,
  resources can not be preempted
- circular wait

semaphore
semaphore is one of the simplest synchronization mechianism used to
control access to a common resource by multiple processes in a concurrent system 
it is a variabelw with a value range between 0 to N, where N is maximu mresources-1,
 when it is 1, it is mutex, binary semaphore
- a binary semaphore
  - only takes the vaalues 0 and 1
- a general semaphore
  - can take many positive values 
- suppose a semaphore variable sv
  - P (semaphore variable) for wait
    - if sv is greater than zero, decrement sv,
      if sv is zero, suspend execution of this process
  - S (semaphore variable) for signal
    - if some other process has been suspended waitting for sv, make it resume execution
      if no process is suspended waitting for sv, increment sv
    emaphore sv = 1;
    loop forever {
    P(sv);
    critical code section;
    V(sv);
    noncritical code section;
    }

virtual memeory
paging
the mapping from virtual to physical address is done by the memory management unit, MMU, which is a hardware device and this mapping is known as paging technique
it ensures that the physical address of space to be non-contiguous
in this the virtual memory is divided into fixed size pages and the physiccal memory is divided into equal szie called page frames

paging
it is generally a memory management technique that allows OS
to retrieve processes from secondary storage into main memory
it is a non-contiguous allocation technique that divides each process in the form of pages

segmentation
it is generally a memory management technique that divides processes into modules and parts of different areas
these parts and modules are known as sgements that can be allocated to process
in segmentation, we divide the process into modules for better visualization of the process
segmentation divides the user program and the secondary memory into uneven-sized blaocks known as segments

paging divides the memory into some fixed-sized black 
segmentation divides the user program and the secondary emmeory into uneven-sized blocks 

ways to prevent deadlock
- distribute resources in the beginning
- time the lock time

trashing in OS
it is generally a situaion where the CPU performs less productive work nad more swapping or paging work
it spends more time swapping or paging activities rather than its execution

semaphore
is a signaling mechanism
it is simply used to solve the problem or issue of critial sections in the synchronization process by using two atomic operations
wait() and signal()


===
xv6
a kernel, a pecial progra that provides services to running programs
each running program, called a process,
  - has memory containing instructions, data and a stack
  - when a process needs to invoke a kernel service,
      it invokes a system call
      the system enters the kernel
      the kernel performs the service and returns
      thus a process alternates between executing in user space and kernel space

the collection of system calls that a kernel provides is the interface that user programs see
the kernel associates a proceesss identifier or PID with each process

the xv6 shell is a simple implementation of the essence of the Unix Bourne shell.
- shell allows user to redirect I/O
  - ls > out
    cat out
    grep x < out
- shell create a new process to run command
  - shell fork() a process to run ls
    - the child process calls exec()
    - wait(), wait for the child created by fork(), any of its children
       int status;
       wait(&status);
       // the status argument is a way for an exiting child to communicate one integer 32-bit value from the exiting child to the waiting parent
       exit(1);
       // 1 is thee argugment to exit, OS passes 1 from the exiting child to the status.
       // &status, is passing the address of the status variablee to the kernel, the kerneel fills in that address with the child's argument to exit
       // convention in Unix, a program completes successfully it exits with state of zero;
       // if it encoutered an error, the unix convention is that you pass one to exit

- fork
  - a process may craete a new process using the fork system call
  - fork gives the new process an exact copy of the calling process's memory, both instructions and data
  - fork returns in both the original and new processes
    - in the original process, fork returns the new process's PID
    - in the new process, fork returns zero
  - the original and new processes are often called the parenet and child
  - if a given process called fork() twice, and it wannts to wait for both children it has to call wait() twice.
    - each call of wait() wouldd return as soon as one of the children exits,
      you dont neceessarily know which child is exited.
      wait() returns the child's process id, so you can tell after it returns

- exit
  the exit system call casues the calling process to stop executing and to release resourcs such as memory and open files
    - it take an integer status argument
      0 to indicate sucess
      1 to indicate failture

- wait 
  the wait sysem call returns the PID of an exited(or killed) child of the current process and copies the exit status of the child to address passed to wait
  - if none of the caller's children has exited, wiat for one to do so
  - if the caller has no children,, wait immediately returns -1
  - if the parent doesnt care about the exit status of a child, it can pass a 0 address to wait

although the child has the memory contents as the paret initially, the parent and child are executing with separate memry and separate registers

- exec
  - the exec system call replaces the calling process's memory with a new meory with a new memory image loaded from a file stored in the file system
  - the file must have a particular format, which specifies which part of the fil holds instructions, which part is data, at which instruction to start, etc.
  exec takes two arguments
    - the name of the file containing the executable
    - an array of string arguments
  - replaces the calling process with instructions read from a paarticular file
      loads the instrctions from that file over the current process
      discard its current memory, relace the current memory
      then starts eexecuting those instructions
      exec() preserves the current of fd table
      exec() doesnt return, because it replaces its current process's memory
      in additioin you can pass arguments, command line arguments
      cha* argv[] = {"echo","this","is","echo",0};
      // each string is a pointer some memory that contains those bytes
      // 0 marks end of a array, null pointer
      exec("echo",argv); 
  - fork() copied the entire parent process, but exec() throws away all the copied memory and replaces it with whatever is in the file you are runnning
    - lazyfork()
  - exec() a bit expensive
    - load all those instructions
      - access the file system and access the disk
      - read the contents of a file called echo off the disk into memory
      - allocating some memory and freeing some memory from oldd process

- the main sturcture of the shell on xv6
  - reads a line of input from the user with getcmd
  - then it calls fork
  - the parent calls wait
  - the child runs the command

- I/O and file desciptors
  * by defalut, when a program starts, fd 0 is connected to console input, fd 1 is connected to console output
  -  a file descriptor is a samll integer representing a kernel-managed obejct that a process may read from or write to
  - a processs may obtain a file descriptor by opening a file, directory, or device, or by creating a pipe, or by duplicating an existing descriptor
  - by convention, a process
    - reads from file descriptor 0, standard input
    - writes ourpur ro file descriptor 1, standard output
    - writes error messages to file descriptor 2, standard error
  - read(fd,buf,n)
    * fd to the previous opened file
    * buf: pointer to some memory
    - reads at most n bytes from the file descriptor fd, copies them into buf, and returns the number of bytes read
    - each file descriptor that refers to a file has an offset associated with it, read reads data from the current file offset and then adcances that offset by the numberof bytes read: a subsequent read will return the bytes following the ones returned by the first read.
  - write(fd,buf,n) , wrties n bytes from buf to the file descriptor fd and returns the number of bytes written, each write picks up where the previous one left off.
  - the close system call releases a file descriptor, making it free for reuse by a future open, pipe, or dup system call
  - file descriptors and forck interact to make I/O redirection easy to implement
  - open(name, flags) 
      int fd = open("output.txt" OWRONLY|O_CREATE);
      // fd a small number, 2 or 3 or 4
      write(fd, "ooo\n",4);
      * fd index a table in kernel
      * kernel maintains state for each process that is running, each programs you run, a table for every process, index by fd
      * each process has their own space of file descriptor
      * same fd number might refers to different files in different process

- the dump system call duplicates an exciting file descriptor, returning a new one that refers to the same underlying I/O object.
  - both file descriptors share an offset, just as the file descriptors duplicated by fork() do.
  - 
    if(fork() == 0) {
      write(1, "hello ", 6);
      exit(0);
    } else {
      wait(0);
      write(1, "world\n", 6);
    }
    At the end of this fragment, the file attached to file descriptor 1 will contain the data hello world. 
    The write in the parent (which, thanks to wait, runs only after the child is done) picks up where the childs write left off. 
  - 
    This is another way to write hello world into a file:
    fd = dup(1);
    write(1, "hello ", 6);
    write(fd, "world\n", 6);

- pipes
  a pipe is a small kernel buffer exposed to processes as a pair of file descripts,
   one for reading and one eof writing
  writing data to one end of the pipe makes that data available for reading from the other end of the pipe
  pipes provide a way for processes to communicate
 
  - three adcantages over temporary files 
    - pipes automatically clean themselves up
    - pipes can pass arbitratily long streams of dara
    - pipes allow for parallel excution of pipeline stages 

- file system
  - inode
    metadatra
  - links

- the Unix system call interace has been standardized through the 
Portable Operating System Interface (POSIX) standard

- multiplexing
- isolation
  - to achieve strong isolation its helpfil to forbid applications from
   directly accessing sensitive hardware resources, and instead to abstract the resources into services
  - RISC-V has three modes
    - machine mode
      configuring a computer
    - supervisor mode
      - enabling and disabling interrupts
      - reading and writing the register tht holds the address of a page table 
    - user mode
      - an application can execute only user mode instrctions is said to be running in user space
- interaction

- monolithic kernels
- microkernels

- layout of a process's virtual address space
  MAXVA: trampoline
         trapframe
         heap
         user stack
  0:     user text and data

- the RISC-V page table translates a virtual address to a physical address

- factors that limit the maximum size of  process's address space
  - pointers on the RISC-V are 64 bits wide
  - the hardware only uses the low 39 bits when looking up virtual addresses in page tables
  - and xv6 only uses 38 of 39 bits
  - thus the maximum address is 2^38 -1 = 0x3ffffffff
  - MAXVA -> 0x3ffffffff
- the trampoline page contains the code to transition in and out of the kernel 
- mapping the trapframe is necessary to save/restore the state for each process

- a process bundles two design ideas
  - an address sapce to give a process the illusion of its own memory 
  - a thread to give the process the illusion of its own CPU
  * in real OS, a process may have more than one thread to take advantage of multiple CPUs.

===
starting xv6, the first process and system call

- when a RISC-V computer powers on, it initializes itself and runs a boot loader 
which is stored in read-only memory
- the bootloader loads he xv6 kernel into memory
- in machine mode, the CPU executes xv6 starting at _entry
- the RISC-V starts with paging hardware disable: virtual address map directly to physcial addresses
- the loader loads the xv6 kernel into memory at physical address 0x800000000.
  - the reason it places the kernel at 0x800000000 
  rather than 0x0 is because the address range 0x0 -> 0x800000000 contains I/O devices
- the instructions at _entry set up a stack so that xv6 can run C code
- xv6 declares space for an initial stack, stack0
- the code at _entry loads the stack pointer register sp with the address stack0+4096, 
the top of the stack. because the stack on RISC-V frows down.
- now that the kernel has a stack, _entry calls into C code at kernel/start.c

- the function start performs some configuration that is only allowed in machine mode 
  and then switches to supervisor mode
- to enter supervisor mode, RISC-V provides the instruction mret
  - the instruction mret is most often used to return from a previous call 
    from supervisor mode to machine mode
  - start isn't returning from such a call, and 
  - instead sets things up as if there had been one: 
    it sets the previous privilege mode to supervisor in the register mstatus, 
  - it sets the return address to main by writing main's address into the register mepc, 
  - disables vitrual address translation in supervisor mode by writing 0 into the page-table register satp,
  - and delegates all interrupts and exceptions to supervisor mode
- before juming into supervisor mode, start performs one more task: 
  it programs the clock chip to generate timer interrupts
- after all that, start "returns" to supervisor mode by calling mret
- that would cause the program counter to change to main
- after main initilizes several devices deices and subsystems,
  it creates the first process by calling userinit
- the first process executes a small program written in RISC-V assembly,
  which makes the first system call in xv6
- initcode.S loads the number of the exec system call,
 SYS_EXEC into register a7 and calls ecall to re-enter the kernel
- the kernel uses the number in register a7 in syscall to call the desired system call
- the system call table maps SYS_EXEC to sys_exec, which the kernel invokes
- once the kernel has completed exec, it returns to user space in the /init process
- init creates a new console device file if needed 
 and then opens it as file descriptors 0,1, and 2. then it starts a shell on the console. the system si up

- security
  - the OS must assume that a process's user-level code will fo its best to wreck the kernel 
  or other processes
    - try to dereference pointers outside its allowed address sapce
    - it may attempt to execute any RISC-V instructions
    - try to read and write any RISC-V control register
    - it may try to directly access deivce hardware
    - it may pass clever values to system calls in an attempt to trick the kernel into 
    crashing or doing somethin stupid

===
page table
- page tables are the most popular mechanism through which the OS provides wach process with its own private adress space and memory
- page tables allow xv6 to isolate different process's ddress spaces and to multiplex them onto a single physical memory

- RISC-V instructions (both user and kernel) manipulate virtual addresses.
- the machine's RAM, or physical memory is indeed with physical addresses
- the RISC-V page table hardware connects these two kinds of addresses, by mapping each virtual address to a physical address

- xv6 runs on sv39RISC-V, means only the bottom 39 bits of a 64-bit virtual address are used, the top 25 bits are not used
- in this sv39 configuration, a RISC-V page table is logically an array of 2^27, 134217728 page table entries (PTEs).
- each PTE contains a 44-bit physical page numebr (PPN) and some flags
- the paging hardware translates a virtual address by 
  - using the top 27 bits of the 39 bits to index into the page table to find a PTE,
  - and making a 56-bit physcial address whose top 44 bits come from the PPN in the PTE
  - and whose bottom 12 bits are copied fromthe original virtual adress
  virtual address 64:
       |index |offset
    25 |27    |12     -------------------
         |                              |
         |  44 | 10                     | 
         -> PPN| flags                  | 
             |                          |
             ------------------------   |
                                    |   |
                                    v   v
              physical address 56: 44| 12

- a page table gives the OS control over virtual to physical address translations 
  at the granularity of aligned chunks of 4096(2^12) bytes. suck a chunk is called a page
- in sv39 RISC-V, th top 25 bits of a virtual address are not used for translation, 
  the physcial address also has room for growth, 2^39 = 512 GB, shoudl be enough

- a RISC-V CPU translates a virtual address into a physial address in three steps:
  - a page table is stored in physical memory as a three-level tree:
    - the root of the tree is a 4096-byte oage-table page that contains 512 PTEs
      - which contain the physical addresses for page-table pages in the next level of the tree
    - the paging hardware uses the top 9 bits of the 27 bits to select a PTE in the root page-table page
    - the middle 9 bits to selet a PTE in a page-table page in the next level of the tree
    - and the bottom 9 bits to select the final PTE

- if any of the three PTEs required to translate an address is not present, 
  the paging hardware raises a page-fault exception, leaving it up to the kernel to handle the exception

- the three-level structure allows a memory-efficient way of recording PTEs, 
compared to the single-level design
- one down side:
  - CPU must load three PTEs from memory to perform the translation of the virtual address 
  in the load/store instruction to a physical address
    - to avoid the cost of loading PTEs from physical memory, a RISC-V CPU caches page table entries 
    in a Translation Look-aside Buffer (TLB)
  
- each PTE contains flag bits that tell the paging hardware how the associated virtual ddress 
  is allowed to be used
  - PTE_V indicates whether the PTE is present,
      if it is not set, a reference to the page causes an exception
  - PTE_W controls whether instructions are allowed to write to the page
  - PTE_R controls whether instructions are allowed to read to the page
  - PTE_U controls whether instructions in user mode are allowed to access the page
      if it us not set, the PTE can be used only in supervisor mode
  - PTE_X controls whether instructions the CPU may interpret the content of the page 
  as instruction and execute them

- to tell a CPU to use a page table, the kernel must write the physical address of 
  the root page-table page into the satp register
  - a CPU will translate all addresses generated by subsequent instructions 
  using the page table pointed to by its own satp
  - each CPU has its own satp so that different CPUs can run different processes, 
  each with a privte address space described by its own page table
  
- physcial memory refers to storage cells in DRAm
- A byte of physical memory has an address, called a physical address
- instructions use only virtual address, which the paing hardware translates to physcial address,
  - and then send to the DRA hardware to read or write storage.

- xv6 maintains one page table per process, describing each process's user address space,
 plus a single page table that describes the kernel's address space

- the kernel gets at RAM and memory-mapped device registers using irect mapping
  - that is mapping the resources at virtual addresses that are equal to the physical address
    - for example, the kernel itself is located at KERNBASE = 0x80000000 in both virtual and physical memory
    - direct mapping simplifies kernel code that reads or writes physical memory
    - For example, when fork allocates user memory for the child process, 
      the allocator returns the physical address of that memory;
      fork uses that address directly as a virtual address when it is copying the parents user memory 
      to the child.
  - a couple of kernel virtual addresses that aren't direct mapped:
    - the tranpoline page
      - it is mapped at the top of the virtuaal addresss space
    - the kernel stack pages
      - each process has itw own kernel stack
      - which is mapped high so that below it xv6 can leave an unmapped guard page
      - the guard page's PTE is invaild (PTE_V is not set)
      - so that if the kernel overflows a keernel stack, 
      it will likely cause an exceeption and kernel will paanic
      - without a guard page an overflowing stack would oveerwrite other kernell memory,
       resulting in incorrect operation. a panic crash if preferrable

- creating an address space
  - the central data structure is pagetable_t, which is a pointeer to aa RISC-V root page -table page

===
* the processs model
  - sequential processes
  - a process is an instance of an executing program, 
  including the value of the program counter, registers and variables 

- process creation
  - system initialization
  - execution of a process-creation system call by a running processs
  - a user request to create a new process
  - initiation of a batch job

- process termination
  - normal exit, voluntary
  - error exit, voluntary
  - fatal error, involuntary
  - killed by another process, ivoluntary

- process states
  - running, actually using the CPU at that instant
  - ready, runnbale, temporarily stopped to let another process run
  - blocked, unable to run until some external event happens

- implementataion of processes
  - process table, aka, process control blocks
    - to implement the process model, the operating system maintains a table,
     an array of structures, with one entry per process
    - some of the fields of a typical process table entry:
      - process management
      - memory management
        - pointer to text segment info
        - pointer to data segment info
        - pointer to stack segment info
      - file management
    - this entry contains important information about the process' state, 
    like, program counter, stack pointer, memory allocation, the status of its open files, 
    its accounting and scheduling information and everything else 
    about the process that must be saved when the process is switched from running to ready or blocked state 
    so that it can be restarted later
      - all interrupts start by saving the registers, often in the process tbale entry for the current process
      - and then the inforamtion pushed onto the stack by the interrupt and 
      then they are removed and the stack pointer is set to point to a temporary stack used 
      by the process handler

* process
- each process provides the resources needed to execute a program
- each process is started with a single thread, the primary thread
* thread
- a thread is an entity with in a process that can be scheduled for execution.
- the ability for the parallel entities to share an address space and all of its data among themselves
- threads are lighter weight than processses
- threads are useful on systems with mulitiple CPUs, where real parallelism is possible
- threads run in a shared memory space (of the same process)
- processes run in separate memory spaces

- threads, parallelism, blocking system calls
- single-threaded process, no parallelism, blocking system calls
- finite-state machine, parallelism, nonblocking system calls, interrupts

- process
  - it is a way to group related resources together
  - a process has an address space containning program text and data as well as other resources

- thread
- a process as a thread of execution

- processes are used to group resources together
- threads are the entities scheduled for execution on the CPU

- Pthreads from IEEE
  - pthread_create
  - pthread_exit

- implement threads in user space
  - put the threads package entirely in user space
    - implemented by a library
  - thread table to keep track of the threads in that process

- InterProcess Comunication, IPC
  - race condition
    - situation when two or more  processes are reading or 
    writing some shared data and the final result depends on who runs precisely when
  - mutual exclution
    - some way of making sure that if one process is using a shared variable or file, 
    the other processes will be excluded from doing the same thing
  - cirtical region, critical section
    - where the shared memory is accessed
    - range matters such that no two processes were ever in their critical region 
    at the same time to avoid races

- mutal exclusion with busy waiting
  - disabling interrupts
    - on a single-processor system, the simplesy solution is to have each process disble all interrupts
     just after entering its critical region and re-enable them ust before leaving it
    - with interrupts disabled, no clock interrupts can occur
    - with a multiprocessor system ( with two or more CPUs) disabling interrupts 
    affects only the CPU that executed the disable instruction. 
    the other ones will continue running and can access the shared memory
  - lock variables
    - read a lock before entering its critical region
  - strict alternation
    - continously testing a variable until some value appears is called busy waiting
      - it should usually be avoided, since it wastes CPU time
      - only when there is a reasonable expectation that the wait will be short is busy waiting used
      - a lock that uses usy waiting is called a spin lock

  - peterson's solution
    - enter_region()
    - leave_region()
  - the TSL instruction
    - test and set lock 
    - it reads the contents of the memory word lock into register RX 
    - and then stores a nonzero value at the memory address lock
    - the operations of reading the word and storing into it are guaranteed to be indivisible
      - no other processor can access the memory word until the instruction is finished
    - the CPU executing the TSL instruction locks the memory bus to prohibit other CPUs from accessing memory until it is done, hardware on the bus line
    - an altternative instruction to TSL is SCHG
      - which exhanges the contents of two locations atomically
        - TSL REGISTER, LOCK
          CMP REGISTER, #0
        - MOVE REGISTER, #1
          XCHG REGISTER, LOCK
          CMP REGISTER, #0
  - both peterson's solution and the solutions using TSL or SCHG are correct, but both waste CPU time
    - priority inversion problem
  - slepp and wakeup
    - sleep is a systemc all that causes the caller to block, thay is be suspended until another process wakes it up
    - the wake up call has one parameter, the process to be awakened

- semaphore
    - a semaphore could have the value 0, indicating that no wakeups were saved
    - or some positive value if one or more wakeups were pending
    - down and up operation
      - the down operation on a semaphore checks to see if the value is greater than o 
        - if so, it decreaments the vlaue (uses up one stored wakeup) and just continues
        - if the value is 0 the process is put to sleep wihtout completing the down for the moment
      * checking the vlaue, changing it and possibly going to sleep 
      are all done as a single indiisible aromic action
      - the up operation increments the value of the semaphore addressed
        - if one or more processes were sleeping on that semaphore with processes sleeping on it,
         the semaphore will still be 0, but there will be one fewer process sleeping on it

- mutexes
    - a simplified version of the semaphore, binray semaphores
    - when the semaphore's ability to count is not needed
    - a shared vaiable, two states, unlocked or locked

* memory management
  - memory hierarchy

* scheduling
- scheduler

- scheduling algorithm

* ecall
- change mode from user to superviosr
- save PC and sepc (supervisor exception program counter)
- jump to the insturction that stvec points to 

* implement virtual memory features using page faults
- lazy allocation
- copy, write, fork
- demand paging
- mma, memory map files
 
- the faulting virtaul address
- the type of page fault
- the virtual address of the instruction ythat caused the fault
  - sepc, supervisor exception progrm counter in the trap frame, epc

* virtual memory
- isolation
- level of indirection
  - virtual address -> physical address
    - trampoline
    - guard page
    - static mapping
      - using page faults, we change the mapping
 
- overlays
  - split programs into little pieeces, called overlays

- virtual meemory
  - each program has its own address space
  - which is broken up into chunks called pages
  - each page is a contiguous range of addressses

- virtual memory -> MMU (mmeory management unit) -> memory bus
- the virtual address space consists of fixed-size units called pages 
- the correspondingg units in physical memory are called page frames
- the relation betweeen virtual addresses and physcial memory addresses is given by the page table
- if the program references an ummapped address (present/absent bit) -> page fault

- TLB, translation lookaside buffer, associative memory
  - MMU first look up TLB, and then does an ordinary page table lookup
    - if miss in TLB, replacee the entry
    - wont cause trap, traps only occur when a page is not in memory
    - TLB misses occuur much more frequently than page faults
      - soft miss, not in TLB, but in memory
      - hard miss,, not in TLB and memory
        - a disk aaccess is required to bring in the page
      - minor page fault
      - major page fault
      - segmentation fault, invaild access

* deadlock
- preemptable resource
- nonpreemptable resource

- four conditions must hold for theree to be a resource deadlock
  - mutual exclsusion condition
  - hold anad wait condition
  - no preemption condition
  - circular wait condition

* SSH
  - secure shell protocol
    - a remote admnistration protocol that allows users to accress, 
    control and modify their remote servers over the internet
    - it provides a mechanism for authenticating a remote user
  - ssh {user} @{host}

* terminal tricks
- ctrl F forward by a ward
- ctrl B backward by a ward
- ctrl P last command
- ctrl N next command
- ctrl a the begining
- ctrl e the end 

* ifconfig
- a network interface
  - is the point of conection between a computer and a network
- Linux distinguishes two types of network interface
  - the physcical network interface
    - a network hardwaree device such as 
      - NIC (network interface card),
      - WNIC (wireless network interface card)
      - a modem
  - the virtual network interface
    - linked to a network device
  - ls /sys/class/net
  - ip link
  - ifconfig
  - ip addr

* differential signaling, CAN
  - ground is noise, signal is noise
  - those two wires are set up to always show the exact opposite signal of its companion wire
    
* can-util
- for virtual CAN interface
  sudo modprobe vcan
  sudo ip link add dev vcan0 type vcan
  sudo ip link set up vcan0
- for native interface
  - slcand
    - userspace daemon for serial line CAN interface driver SLCAN
  sudo ip link set can0 type can bitrate 125000
  sudo ip link set up can0
- cangen van0
  - candump van0
    - candump -l van0
      - candump would log the can frames
- canplay
  - it would replay the can frames  
  - canplay -I canfile.log
- cansniffer
  - CAN sniffer is used to see thee change in CAN traffic
  - cansniffer -c vcan0

========
# startup
- Firmware, copy BIOS to RAM
- Harddrive, master boot record systems
  - Load bootloader from harddrive to RAM
    - Bootloader would use partition table, file systems
      - /boot/grub/grub.cfg
    - Bootloader loads the kernel to RAM
      - /boot/kernel.bin
  - bootloader won't set stack pointer
    - loader.s
      - set the stack pointer
      - compiled with as
      - loader.a
    - kernel.c
      - compiled with gcc
      - kernel.o
    - ld, linker
      - kernel.bin
      - bootloader would look for a magic number in kernel.bin
      - 0x1badb002
      - bootloader would store a struct called multoboot, containing RAM info
        - multiboot.h from GNU

- in grub.cfg
  - menuentry 'my operating system'{
      multiboot /boot/myKernel.bin
      boot
    }

- Create type.h
  - In case of size change for premative data type, int...
  - So when different compliers are used, only need to change type.h

# printf
- No exception handling and dynamic memory management when in bare metal.
- Linux would link your program to Glibc in normal case.
- Write to 0xb8000 woulld result to outpu from graphic.
- Frist byte, color inforamtion.
  - First and second half are for foreground and background color.

========
# linux from scratch
- master boot record + boot partition + root partition
- init(system-V/stsemd)
- /etc/fstab

### linux kernel source code
- ../drivers
  - variious Ethernet network cards, USB controlers, numerous hardware devices
- ,,/arch\
  - containing support for more than 20 unique processor architectures
- System.map
  - the kernel symbols and their respective addreses
- vmlinux
  - an architecture-specific ELF file in executable format
- the dot-config
  - make help
    - config, menuconfig, xconfig, ...
  - Text based and graphical editors are degisned to edit kernel configuration.
  - And outputs .config
- linux is monolithic
  - The entire kernel is compiled and linked as a single staticaly linked executable.
  - Dynamic insertion into a running kernel
    - Dynamically loadable module
- make
  - bzImage for x86/PC atchitecture, only suitable for PCs with an industry-standard BIOS
  - zImage 
  - make ARCH=arm help
- bootstrap loader
  - second-stage loader, loads linux kernel into memory
- head.S
  - Checks for vaild processor and architecture
  - Creates initial page table entries
  - Enbales the processor's MMU
  - Establishes limited error detection and reporting
  - Jumps to start_kernel() in main.c
- kernel command line
  - Controls various aspects of linux kernel behavior
    - Specifying the root partition
    - Enabling debug messages
    - Di0sabling specific hardware drivers
    - Setting boot delay
  - Usually, set by bootloader like GRUB.
  - .../Documentation, kernel-parameters.txt
  - A set of arguments passed to the kernel at boot time
    - cat /proc/cmdline
- rest_init()
  - Called by start_kernel()
    - Created two threads, start_kernel() and init()
      - start_kernel() would enter cpu_dile() loop in the end
  - The kernel's init process is spawned by ketnel_thread() in rest_init()
  - kernel_init()
    - do_initcalls()
      - calls most of initialization functions registered with *_initcall family of marcos
## User space initialization
- run_init_process() is a wrapper for execve() 
  - execve() never returns if no error conditions are encountered
    

========
dpkg -l
sudo update-pciids
lspci
lspci -s "00:03.0" -vvv
cat /proc/cpuinfo
cat /proc/meminfo

========
# Virtualization
- Virtualizing the CPU
  - prompt> ./cpu A & ./cpu B & ./cpu C & ./cpu D &
    [1] 7353
    [2] 7354
    [3] 7355
    [4] 7356
    A
    B
    D
    C
    A
    B
    D
    C
    A
  - Turning one CPU into a seemingly infinite number of CPUs.
    Allowing many programs to seemingly run at once.
- Virtualizing the memory
  - prompt> ./mem & ./mem &
    [1] 24113
    [2] 24114
    (24113) address pointed to by p: 0x200000
    (24114) address pointed to by p: 0x200000
    (24113) p: 1
    (24114) p: 1
    (24114) p: 2
    (24113) p: 2
    (24113) p: 3
    (24114) p: 3
    (24113) p: 4
    (24114) p: 4
  - Each proces accesses its own private virtual address space
- Concurrency
  - Threads
  - Atomically (all at once)
- Persistence
  - Data persistence to volatile memory
  - File system, OS software that manages the disk

# Process
- The abstraction provided by the OS of a running program.
- Summarize a process by 
  - Taking an inventory of the different pieces of the system
    it accesses or affects during the course of its execution.
  - Machine state
    - Memory, addres sapce
    - CPU registers, Program counter, stack pointer, frame pointer.
    - information about I/O 
      - such as open files which can be read or written.
- Process in memory
  - Program is stored in Disk
    Load proragm to Process in memory from disk
  - Loading can be done
    - Eagerly, all at once before running the program
    - Lazily, loading pieces of code and data only as they are
              needed during program execution.
    - Paging and swapping
    --------
   | (process in memory)|  
   | code               |  
   | static data        |  
   | heap               |  
   |                    |  
   | run time stack     |  
    --------
- In UNIX, each proces by default has three file descriptors
  - Standard input, output and error.
- Time sharing
- Space sharing
- Process states
  - Running, Ready, Blocked
    - When one process initiates an I/O request to a disk
      the process becomes blocked and thus some other precess
      can use the process.
- A proces list contains information about all processes in the system
  - Each entry is called process control block (PCB).
  - PCB contains a structure that contains information about a specific process.

- Monolithhic kernel design
  - User space and kernel space
  - Tight integration
- Micro kernel design
  - Small kenrel, most of drivers are in user sapce, 
    it does IPCs to user space
  - Worse proformence

# File System
- User-friendly names/ pathnames.
- Share files between users/processes.
- Persistence/ Durability.
- Abstraction is useful.
- Crash safety 
- Disk layout
- Performance
  - Storage devices are slow
    - Buffer cache
    - Concurency
- Block cache, block read from disk.
- fs = on-disk data structure.
- mkfs

# File System Structure
- inode
  - File info, independent of name.
  - Link count, link name to a inode (link(), unlink())
  - Open fd count
    - Fd must maintain an offset.
  - A file can be deleted when link count and open fd count is zero,
- ls -i, shows inode ID
- df -i, shows toal inodes and used inodes.
- stat, shows detailed info about a file or directionory.

# File system layers
- name fds
- inode
- icache, inode cache -> synchronization 
- Logging
- Buffer cache
- Disk
  - SSD
  - HDD, magnatic disk
  - Sector on disk
  - Block on OS, one or more sector

# Disk layout
- 0, boot sector, 
  - A piece of OS kernel code, and would load the reset from disk.
- 1, super block, describes the file system
- 2 to 32, log
- 32 to 58, inodes
  - 46, bitmap indicated the usage of data blocks
- 0 46 to the end, data

# On-disk Inode
- Type, directory or files
- Nlink
- Size
- Direct block number 0 to 12.
- Indirect block which points to a 256 blocks
- Max file size is (256+12)*1024

# Directories
- dir, is a file with some structure.
- /usr/dic, the first '/' indicated root inode.
  - Scans block for name "usr"

* ar
- the GNU ar program creates, modifies, and extracts from archives
- an archive is a single file holding aa collection of other files in a structure that makess it possible to retrieve the original individual files

* kill -1 1234 >/dev/null 2>&1
- use the Linux universal 'bit bucket' of /dev/null to efficiently discard the entire output
- including redirecting both output of kill and standard output

* use gdb to print struct

* fopen vs open
- fopen is a library function
  open is a system call
- fopen provides buffered IO, faster 
  open is non buffered
- fopen is portable
  open is not portable, open is environment specific
- fopen returns a pointer to a FILE structure (FILE *)
  open returns an integer that identifies the file

====
# Locks
- Locks for correct sharing.
- Locks can limit performance.
- Avoid race conditions.

=== 
# GDB
- x /10i 0x12345678
- x /10m 0x12345678
  - https://attie.co.uk/wiki/gdb/read_from_memory/
  - https://sourceware.org/gdb/current/onlinedocs/gdb.html/Memory.html
- info break
- step/continue
- delete (deletes all break points)
- watch a 
- set car a=12
- set *(0x7fffffffe34c) = 12
- target record-full
- reverse-next
- info registers

===
# wget
- http://host[:port]/directory/file
- ftp://host[:port]/directory/file
- http://user:password@host/directory/file
- ftp://user:password@host/directory/file
- --user and --password, --ask-password

- -b, background
- -o log.txt, create a log file.
- -a log.txt, append to a log file.
- -c, continue downloading.
- wget -p, download all contents.
  - might point to file copies in a server.
- wget -k, download all contents.
  - point to local copies.
- wget -r -l 1, download all contents.
- wget -r -l 3 -p -k -D google.com
  - -D, exclude anything other domain that is not lised
  - --exclude-domains cgn.maplecircuit.dev

====
# Executables
- syscall, execve()
- int execve(const char *pathname, char *const argv[],
                char *const envp[]);
- strace -e execve whoami
- execve("/usr/bin/whoami", ["whoami"], 0x7fff6d88f330 /* 23 vars */) = 0

- To debug linux kernel with GDB
- Make a kernel image with:
  - KASLR disabled, randomize the address of thge kernel image
  - Virtualization disabled
  - Enable loadable module support disabled
  - Networking support disabled
  - Kernel hacking enabled
  - KGDB enabled
  
- Download Linux source code, apt-get source linux
- Download bash, wget and tar -xvzf 
- gcc -static -o hello --entry main ./hello.c
- ldd hello
  - To check the executable is statically linked, not dynamically linked.
- cat list | cpio -o -H newc > init.cpio 

- add add-auto-load-safe-path ~/linux_source/linux-5.15.0/ to .gdbinit
- qemu-system-x86_64 -kernel arch/x86/boot/bzImage -initrd init.cpio -s
- qemu -s option is used to enable with GDB.
- It makes qemu listen on port 1234 ffor a GDB connection
- (gdb) target remote localhost
- (gdb) target remote :1234
- (gdb) advance 1845


