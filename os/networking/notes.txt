
low-level file input and output file descriptors
file descriptor(fd)
  - 0 represents standard input
  - 1 represents standard output
  - 2 represents standard error
int open(const char* path, int flag);
int close(int fd);

ssize_t write(int fd, const void* buf, size_t nbytes);

char hello[] = "Hi Mom";
it ends with \0

char *str = malloc(4);
str[0] = 'h';
str[1] = 'e';
str[2] = 'y';
str[3] = '\0';
free(str) to RAM

sockets
sockets are the low level endpoint used for processing information across a network
common networking protocols like HTTP, and FTP rely on sockets underneath to make connections

client socket workflow
the client socket if created with a socket[] call, types of sockets
connect to a remote address with the connect[] call, IP and the port
retrieve data with the recv[] call

- creating a scoket, a socket descriptor
to perform network I/O,
call the socket function to create a apecific type of scket by specifiying the type of communication protocol desired, protocol family, etc
#include <sys/socket.h>
int socket(int domain, int type, int protocol);

- binding the scoket
sockets do not have a complete address in the beginning to start transferring data
so we bind a socket to a port
the process of allocating a port number to a socket is called binding
binding a request to TCO/IP indicating that it is ready to receive/send information:w
int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);

- listen, listen for connection requests
the process of converting an unconnected socket into a passive socket
indicating tht the kernel should accept incoming connection requests directed to this socket
int listen(int sockfd, int backlog);

- accept, accept a connection request
transition of the connect request from listen() method to an actual socket
after accepting the request, the data can be finallly transferred between the nodes
int accept(int sockfd, struct sockaddr *addr, socklen_t* addrlen);

- connect, attempting to establish a connection 
the implementation of requesting to connect is very simple, unlick listening and accepting a socket
int connect(int sockfd, struct sockaddr* serv_addr, socklen_t addrlen);

socket domain
- AF_XXX, address family(each address family supports multiple protocol families
  - AF_INET, address family internet IPv4
  - AF_INET6, address family internet IPv6
- PF_XXX, protocol family, same as AF_XXX

socket type
- SOCK_STREAM, TCP(transmission control protocol, two way handshaking
  connection oriented, stable
- SOCK_DGRAM, UDP(user datagram protocol, doesnt shank any hands)
  connectionlesss, fast

socket protocol, sub protocol of the selected socket type
  cat /etc/protocols

server socket workflow
socket() -> bind() -> listen() -> accept()

client socket workflow socket() -> connect() -> recv()
===
a TCP-based HTTP client written in C, transmission control protocol
- find n http service which responds in the data you need
- learn socket programming in C
- create a TCP socket and send a HTTP request to that service you found in 1
- read the response from the socket to require your data

===
internet address + port -> socket 

- internet (logical) address
  an internet protocol address (IP address or logical address) is a numerical label assigned 
  to each device connected to a computer network that uses the internet protocol for communication

  classful address or IP address
  133.122.123.211, 4 bytes
    133 -> net id
    122.123.211 -> host id
  subnet mask decides the portion

  classless IP network
  CIDR Notation

- port number
  port number is the logical address of each application or process that uses a network or the internet to communicate
  a port number uniquely identifies a netwoek-based appliction on a computer

  port 80 for web brower, it uses port 80 to reach the server by default
  172.217.0.174:80
  
===
internet address representation in C
  - specify a IPv4 address
  - set the port address in both ends of the socket, meaning that sending and receiving sockets must have the same port number
  - struct sockaddr_in -> socket address internet
    - sa_family = socket address family
  - sin_xxxxx -> socket internet xxxxx, "xxxxxx" can be family, port, address)
  - struct sockaddr_in
    {
      sa_family_t  sin_family;
      // sin_family, address family(almost always AF_INET)
      uint16_t     sin_port;
      // sin_port, port number
      struct       sin_addr;
      // sin_addr, IPv4 address
      char         sin_zero[8];
      // no special meaning, not used
    };

    struct in_addr
    {
      in_addr_t    s_addr;
    };

    struct sockaddr
    {
      sa_family_t  sin_family;
      char sa_data[14];
    };

  - becasue of little/big endian choice, we conert the port number(short) and IPv4 address(long) using
    - unsigned short htons(unsigned short);
    - unsigned short ntohs(unsigned short);
    - unsigned long htonl(unsigned short);
    - unsigned long ntohl(unsigned short);
    - h: host, n: network, s: short, l: long

- internet address representation
  - allowing any client to make connection requests
  - INADDR_ANY, ip address is not set, it can be any internet address
      mainly for server socket to accept any client's request

      # server
      - SW, program that listens for requests and responds
      
      # client 
      - SW, program that makes reuqests of other programs
      
      # netowrk
      - multiple computers connected to each other
      - data can be sent from any system on the network to any other
      - a network is owned and controlled by a person or organiation
      
      # internet
      - network of networks
      - multiple networks connected together by routers
        - private worknets
        - internet service provider
        - backbone networks, tele communication companies
      
      # IP, internet protocol
      - data sent in packets
      - each host and router hasss a unique 32-bit address, IPv4
        - 128-bit address, IPv6
      - router, routing table
        - CIDR, classless inter-domain routing
        - BGP, border gateway protocol
      - modem, short for modulator and de-modulator
        - converts digital signals to analog signals and vice-versa
        - connected to ISP networks and it provides an IP
      - access router
        - allows multiple devices to share one IP addess using network address translation
        = wireless Ethernet connectivity
        - firewall, unwanted traffics
      
      # DNS, domain name system
      - a system of resolving names to IP addresses
      - top-level domains:
        com net org edy mil gov uk ca de etc.
        each controlled by a designated authority
      - most top-level authorities let people lease subdomains:
        google.com, yahoo.com, wikipedia.org, etc.
      - domain name owner determines IP address to which that name resolves
      - DNS server: program which your computer asks to resolve domain names
        - keeps a local cache of the global registry 
        = and periodically checks for updates from the top-level authorities
      
      # URL, uniform resource locator
      - string of text designating location of a thing on the internet
        (nature of the thing)://host(the location, IP address or a domain name)/path(the thing)
      
      # layers
      - Application, HTTP(hyper-text transfer protocol), SMTP(email), etc
      - Transport, TCP, UDP
      - Internet, IP
      - Link, Ethernet (MAC, media access control), etc
      
      - Ethernet header + IP header + TCP header + application date
      
========
# tools
- nmap -p- 10.10.10.142
  - nc -vv 10.10.10.142 8091
    - JSON-RPC
    - curl -X POST --data '{"xyz"}' httpss://10.10.10.142:9810
  - curl httpss://10.10.10.142:9810
- nmap 10.10.10.142
  - Availiable ports
  - ftp 10.10.10.142
    - ftp> get anonymous.txt
  - nc -vz -u 10.10.10.142 30301
- tcpdump -X
- ifconfig
- :set paste
- otool
- xxd
- lldb
- g++ -Os
- g++ -O2

# HTTP server
- Transport layer
  - TCP, transport layer protocols
  - UDP, datagram protocol
  - SPC, sequenced packet exchange
- Socket
  - The mechanism OS provides to give programs access to the network.
  - It allows messages to be sent and received between applications onn different neworked machines
  - int server_fd = socket(domain, type, protocol);
  - Bind
    - Assigning a transport address to the socket(a port number in IP networking)
    - int bind(int socket, const struct sockaddr *address, sockelen_t address_len);
    - struct sockaddr_in
      - { sin_len
      -   sin_family
      -   sin_port
      -   sin_addr
      -   sin_zero[8] }
 - Listen
  - Listen tells a sockete that it should be capable of accespting incoming connections
  - int listen(int socket, int backlog);
  - int accept(int socket, struct sockaddr *restrict_address, socklen_t *restrict_address_len);  
- http://www.google.com:80/index.html
  - Port 80, file index.html, http protocol
      
# Network
- Copper wire
- Fiber Optics
  - FIber strand
  - Cladding
- Radio waves

# Ethernet
- Ethernet address, AKA, MAC address
- Multipoint data link protocol
- Preamble/SFD + Destination addr + Source Addr
  + Ethernet type + payload + frame check sequence
  - Ethernet type 
    - 0800: IP packet
    - 0860: APR

# PPP, point to point protocol
- PPP is for large ISP servers

# IP, Internet Protocol

# ICMP, internet control messgae protocol

# ARP, address resoltion protocol
- To find mac address of the router

# DNS servers
- Root servers maintained by IANA, internet assigned numbers authority.
  - dig, DNS lookup utility
  - SERVER: 192.5.6.30#53(192.5.6.30) 
    - Cache name servers from ISP.
    - dig www.facebook.com 
      - Will lookup from cache name server.
  - a.root-servers.net.	602950	IN	A	198.41.0.4
  - Information about how long can these IPs be cached.
- dig @198.41.0.4 www.facebook.com
  - Get authoritatives for .com 
    - ;; AUTHORITY SECTION:
    - com.			172800	IN	NS	a.gtld-servers.net.
    - a.gtld-servers.net.	172800	IN	A	192.5.6.30
    - a.gtld-servers.net.	172800	IN	AAAA	2001:503:a83e::2:30
- dig @192.5.6.30 www.facebook.com
  - ;; AUTHORITY SECTION:
  - facebook.com.		172800	IN	NS	a.ns.facebook.com.
  - a.ns.facebook.com.	172800	IN	A	129.134.30.12
- dig @129.134.30.12 www.facebook.com
  - ;; ANSWER SECTION:
    www.facebook.com.	3600	IN	CNAME	star-mini.c10r.facebook.com.
    star-mini.c10r.facebook.com. 60	IN	A	31.13.70.36
- dig @129.134.30.12 star-mini.c10r.facebook.com.
- com. -> facebook.com. -> c10rfacebook.com.
- Root server -> Top level domain server -> 
  Facebook naming server -> Facebook sub domain server

- IPv4 Address: 192.168.0.139
- Subnet Mask: 255.255.255.0
  - 34 ones, 8 zeros.
  - First 34 bits of this IP address describe the local network.
  - Last 8 bits describe a single device in this network.

- Router: 192.168.0.1
  - Default gateway to other IPs on the internet.

- netstat -rn -f inet

====
# Network interface
- https://www.youtube.com/watch?v=EnAZB8GI97c
- eth0
- enp0s2, position on the bus
  - en, enthernet adapter
  - p0s2, bus 0 slot 2
- Send packers/ping out using eh0/enp0s2.
- Bind(), nginx server to receive packets from eh0/ennp0se.

- Not common: Add a second address to the same interface.
- Common: have a second interface, another pci endpoint.
- Ethernet/ATM/fiber channel/infiniband <-> Network interface/Adaptor <-> PC Host

- A tunnel, an interface not backed by a actual piece of HW.
  - Like VPN, user applcaition talks to a tunnel which then the piece of SW 
    that is running the tunnel can encpyt and send to the outside world.

- tun0 using NAT, network address translation, replace the source IP address.
- IP_forward
- tap, make a virtual interface pretend to be a enthernet interface with MAC address.
- br0, virtual switch
  - eht0 <-> br0 <-> tap0

====
# ethtool
- ethtool eth0
- ethtool -k eth0
  - See featues represent hardware offload capabilities

# network namespaces
- a kernel feature that provides isolation of networking resources,
  enabling the creation of independent network environments.
- Each network namespace has its own interfaces, routing tables and
  forwarding tables.
- ip route
- ip netns add red
- ip netns add green
- ip netns
- ls /var/run/netns
- ip netns exec red ip link
- add vos, open vSwitch to connect two namespaces
- ifup and if down

- netstat
  - netstat -tln
    - t, tcp
    - l, listen
    - n, show ip and do not resolve hostname

- ARP, address resolution protocol
  - A host sends ARP request in a network.
  - For discovering MAC address associated with an IP address
- DHCP, dynamic host configuration protocol
  - When a device is first connected to a network,
    it sends a DHCP request with lease time and allocate a 
    IP for this device.
- DNS, domain name system
  - A naming system for hostname and IPs
 
- A switch in a network
  - Host
  - DNS server
  - DHCP server
  - Router -> ISP -> internet
- Virutal netoworks using VLAN tags.
- Switch based on MAC adresses
- Router based on IP addresses.

========
# Ethernet driver
- PHY
- PCS, physical coding sublayer blcoks
- MII, media-independent interface, interface to PHY
- MAC, media access control, MAC block

- struct net_device
  - Represents a network interface, visiable with "ip link show"
  - .probe() function of a driver usually registers via netdev_register()
  - Driver specific data retrieved using netdev_priv(dev)
  - User-visible right after register_netdev()
 
- struct net_device_ops
  - NDO, netowrk device operations
  - ndo_start_xmit(), to transmit data, mandatory.
    - Takes skb as a parameter. 
  - netdev->netdev_ops = &my_netdev_ops

- struct sk_buff
  - skb, socket buffer
  - Can be a simple packets or a fragmented packet 
  - Containns a data section (payload + headers) and metadata.

========
# flow
- Packets from the same emitter for the same consumer.
- Flows are identified by data extracted from the headers.
- L3 flow, Source and destination IP address, 2 tuple
- L4 flow, src/dst IP + protocol + src/dst ports, 5 tuple

# RPS
- Receive packet steering
- Interrupted CPU schedules processing on other CPUs.
  - Key data is exacted from the headers and hashed.
- CPU is chosen by masking out the first bits of the hash.
- /sys/class/net/eth0/queues/rx-0/rps_cpus

# RSS
- Receive side scaling
- NIC is configured to extract the header data and compute the hash.
- The interrupt comes to the correct CPU.
- Enable RSS, ethtool -K eth0 rx-hashing on
- Configuring the indirection table, ethtool -X eth0 weight 1 2 2 1
- Dumping the indirection tbale ethtool -x eth0

# RFS
- Receive flow steering
  - RPS and RSS do not care about cache locality.
    - RSS sneds a flow to cpu 1, but cpu2 consumes it
      - RSS sneds a flow to cpu 1, but cpu2 consumes it.

