processor is the heart of an embedded system. it is the basic unit that takes inputs and produces an output after processing the data. 
a processor has two essential units:
-program flow control unit(CU)
-execution unit(EU)

the CU includes a fetch unit for fetching instructions from the meemory.
the EU has circuits that implement the instructions pertaining to data transfer operation and data conversion from one form to another

processors can be of the following cateegories
-general purpose processor(GPP)
	microprocessor, microcontroller, embedded processor, figital signal processor, media processor
-application specific system processor(ASSP)
-application specific instruction processor(ASIPs)
-GPP cores or ASIP cores on either an application specific integratedd ciruit(ASIC) or a very large scale integration(VLSI) circuit

a microprocessor is a signle VLSI chip having a CPU. In addidtion, it may also have other units such as caches, floating point processing arithmetic unit, and pipelining units that help in faster processing of instructions

a microcontroller is a signle-chip VLSI unit. although having limited computational capabilities, possesses enhanceed input/output capability and a number of on-chip functionall units

architecture of the processor:
-Harvard Architectrue
-Von Neumann Architecture

type of instructions set of the processor:
-RISC
-CISC

when data and code lie in different memory blocks, then the architecture is referred as Harvard architecture
in case data and code lie in the same memory block, then the architecture is referred as Von Neumann architecture

===
Von Neumann architecture
In the Von Neumann architecture, one data path or bus exists for both instruction and data.
As a result, the CPU does one operation at a time. It either fetches an instruction from memory, or performs read/write operation on data, so an instruction fetch and a data operation can not occur simultaneously, sharing a common bus
Von-Neumann architecture suppoerts simple hardware, it allows the use of a single, sequential memory. Today's processing speeds vastly outpace memory access times, and we employ a very fast but small amount of memory(cache) local to the processor

===
Harvard architecture
the Harvard architecture offers separate storage and signal buses for instructions and data. 
this architecture has data storage entirely contained within the CPU, and there is no access to the instruction storage as data. 
computers have separate memory areas for program instructions and data using internal data buses, allowing siultaneous access to both instructions and data

===
Von-Neumann architecture:
-single memory to be shared for both code and data
-processor needs to fetch code in a separate clock cycle and data in another clock cycle, so it requires two clock cycles
-higher speed, thus less time consuming
-simple in design

Harvard architecture:
-seeparate meemories for code and data
-single clock cycle is sufficient, as separate buses are used to access code and date
-slower in speed, thus more time consuming
-complex in design

CISC:
-larger set of instrucions, easy to program
-simpler design of compiler, considering larger set of instrcutions
-many addressing modes causing complex instruction formats
-higher clock cycles per second
-emphasis is on hard ware
-control unit implements large instruction set using microprogram unit
-slower execution, as instructions are to be read from memory and decoded by the decoder unit
-pipelining is not possible

RISC:
-smaller set of instructions, difficult to program
-complex deisgn of compiler
-few addressing modes, fix instruction format
-instruction length varies
-low clock cycle per second
-emphasis is on software
-each instruction is to be executed bu hardware
-faster execution, as such instruction is to be executed by hardware
-pipelining of instructions is possible considering single clock cycle

===
a compiler is a computer program(or a seet of programs) that transforms the source codee written in a programming language (the source language) into another computer language(normally binary format). the most common reason for conversion if to create an executablee program.

cross-compiler
if the compiled program can run on a computere having different CPU or operating system than the computer on which the compiler compiled thee program, then that compiler is known as a crossp-compiler

decompiler
a program that can translate a program from a low level language to a high-level language is called a decompiler

languagee converter
a program that translates programs written in different high-leevel languages is normally called a language translator, source to source translator, or language converter

a compiler is likely to perform the following operations
-preprocessing
-parsing
-semantic analysis(syntax-directed translation)
-code generation
-code optimization

assemblers
an assembler is a program that takes basic computer instructions(called as assembly language) and conveerts them into a pattern of bits that the computer's processor can use to perform its basic operations

an assembler creates object code by translating assembly instruction mnemonics into opcodes, resolving symbolic namees to memory locations.

Assembly language uses a mnemonic to represent each low level machine operation(opcode)

# C complilation process
- source.c -> preprocesser -> source.i
  - #include
  - #ifdef
- source.i -> compiler -> source.s
- source.s -> ASM -> source.o
- source.0 -> linker -> source.o
  - Static linker, Other .o file
  - Dynamic linker,  .so, .dylib

editor program
|(myFile.asm)
v
asseembler program -> myFile.lst(list file, it lists all the opcodes and addresses as well as error that the asseemblers deteeected
|(myFile.obj)
v
linker program <- other obj files
|(myFile.abs) (.abs is called an absolute file)
OH program( object to hex convrter, which creates a file with the extension"hex" that is ready to burn in to the ROM
|
v
myFile.hex

===
debugging tools
-simulators
-microcontroller starter kits
-eemulator

simulators
code is tested for the MCU/system by simulating it on the host computer for code development. Simulators try to model the behavior of the complete microcontroller in software

functions of simulators
-defines thee processor or processing device family as well as its various versions for the target system
-monitors the detailed information of a source code part with labels and symbolic arguments as the execution goes on for each single step
-provides the status of RAM and simulated ports of the target system for each single step execution
-monitors system response and determines throughput
-provides trace of the output of contents of program counter versus the processor registers
-provides the detailed meaning of the present command
-monitors the detailed information of the simulator commands as these are entered from the keyboard or selected from the menu
-supports the conditions(up to 8 or 16 or 32 conditions) and unconditional breakpoints
-provides breakpoints and the trace which are together the important testing and debugging tool
-facilitates synchronizing the internal peripherals and delays

mricrocontroller starter kit consists of
-hardware board(evaliation board)
-in-system programmer
-some software tools like compiler, assembler, linker, etc.
-sometimes, an IDE and code size limited evaluation version of a compiler

a big advantage of these kits over simulators is that they work in real-time and thus allow for easy input/output functionality verification. starter kits, however, are completely sufficient and the cheapest option to develop simple microcontroller projects

emulators
an emulator is a hardware kit or a software program or can be both which emulates the functions of one computer system(the guest) in another system(the host).
emulation refers to the ability of a computer program in an electronic devide to emulate(imitate) another program or device. Emulation forcuses on recreating an orihinal computere environment. Emulators have the ability to maintain a closer connection to the authenticity of the digital object. An emulator helps the user to work on any kind of application or operating system on a platform in a similar way as the software runs as in its original environement

a simulator mimics the basic behavior of a device
an emulator deplicayes the thing exactly as it exists in real life

===
peripheral devices in embedded systems
Embedded systems commu nicate with the outside world via their peripherals, such as following:
-Serial Communication Interfaces(SCI), like RS-232, RS-422, RS-485,etc
-Synchronous Seerial Communication Interface, like I2C, SPI, SSC and ESI
-Universal Serial Bus(USB)
-Multi Media Cards(SD cards, cimpact flash, etc)
-Networks like Ethernet, lonWorks, etc
-Fieldbuses like BAN-Bus, LIN-Bus, PROFIBUS,etc
-imers like PLL(s), Capture/Compare and time processing units
-Discrete IO aka General Purpose input/output(GPIO)
-Analog to digital/ digital to analog (ADC/DAC)
-debugging likee JTAG, ISP, ICSO, BDM Port, BITP, and DP9 ports

criteria for choosing microcontroller
-speed
-packaging, is it 40-pin DIP(DUal-inline-package) or QFP(Quad flat packagee)
	this is important in terms of space, assembling and prototyping the end-product
-power consumption, for batteery-powered products
-amount of RAM and ROM on the chip
-cost per unit



===
registers
registers are used in the CPU to store information on temporaraily basis which could be data to be processed, or an address pointing to the data which is to be fetched.

in 8051, there is onee data type is of 8-bit, from the MSB(most significant bit) D7 to the LSV(least significant bit) D0. With 8-bit data type, any data type larger than 8-bits must be broken into 8-bit chunks before it is processed.
the most widely used registers of the 8051 are A(accumulator), B R0-R7, DPTR(data pointer), and PC(program counter). all these registers are of 8-bits, except DPTR and PC.

Accumulator
the accumulaor, register A, is used for all arithmetic and logic operations
if the accumulator is not present, then every result of each calculation(addition, multiplication, shift,eetc.) is to be stored into the main memory.
Access to main memory is slower than access to a register like the accumulator, because the technology used for the large main memory is slower(but cheaper) than that used for a register

the R register
the "R" registers are a set of eight registers, namely, R0,R1 to R7.
these registers function as auxiliary or temporary storage registers in many operations
the "R" registers are very important auxiliary or helper registers. The accumulator alone would not be very useful if it were not for these "R" registers. The "R" registers are meant for temporarily storage of values

the B register
the "B" register is very similar to the Accumulator in the sense that it may hold an 8-bit(1-byte) value. The "B" register is used only by two 8051 instructions: MUL AB and DIV AB. 
To quickly and easily mulitiply or divide by another number, you may store the other number in "B" and make usee of these two instructions.
apart from usng MUL and DIV instrucions, the "B" registere is often used as yet another temporary storage register, much like a ninth R register

the data pointer
the data pointer (DPTR) is the 8051's only user-accessible 16-bit(2-byte) register. the accumulator,R0-R7 registers and B register are 1-byte valye registers.
DPTR is meant for pointing to  data. it is used by the 8051 to access external memory using the address indicated by DPTR. DPTR is the only 16-bti register available and is often used to storee 2-byte values

program counter
the program counter(PC) is a 2-byte address which tells the 8051 whre the next instruction to execute can be found in the memory.
PC starts at 0000h when the 8051 initializes and is incremented every time after an instruction is executed.
PC is not always incremented by 1, some som instructons may require 2 or 3 bytes, in such cases, the PC will be incremented by 2 or 3

branch, jump and interrupt operations load the program counter with an addreess other than the next sequential location
activiating a power-on reset will causee all values in thee register to be lost. it means the value of the PC is 0 upon reset, forcing the CPU to fetch the first opcode from the ROM location 0000. it means we must place the first byte of upcode in ROM location 0000 because that is wheree the CPU expects to find the first instruction

the stack pointer(SP)
the stack pointer, like all registers except DPTR and PC, may hold an 8-bit(1-byte) value. the stack pointer tells the location from where the next value is to be removed from the stack
when a value is pushed onto the stack, the value of SP is incremented and then the valuee is stored at the resulting memory location.
when a value is popped off the stack, the value is returned from the memory location indicated by SP, and then the value of SP is decremented
the order of operation is important. SP will be initialized to 07h when the 8051 is initialized. if a value is pushed onto the stack at the same time, the value will be stored in the internal RAM address 08h because the 8051 will first increment the value of SP(from 07h to 08h) and then will store the pushed value at that memory address(O8h).
SP is modified directly by the 8051 by six instructions: PUSH, POP, ACALL. LCALL, RET and RETI

===
ROM space in 8051
different family members of 8051 have different bytes of on-chip ROM, like 8k, 8K, 32k, 64k bytes, etc.
the point to remember is that no member of the 8051 family can access more than 64k bytes of opcode since the program counter in 8051 is a 16-bit register(0000 to FFFF address)

the first location of the program ROM inside the 8051 has the address of 0000H, whereas the last location can bee different depending on the size of the ROM on the chip, Among the 8051 family members, AT8951 has 4k bytes of on-chip ROM having a memory address of 0000(first location) to 0FFFH(last lcoation)

the program status word(PSW)
the program status word(PSW) register is a 8-bit register, also known as flag register. it is of 8-bit wde but only 6-bit of it is used.
he two unused bits aree user-defineed flags. Four of the flags are called conditional flags. which means that they indicate a condition which results after an instruction is eexecuted. These four are CY(carry), AC(auxiliary carry), P(parity), and OV(overflow). the bits RS0 and RS1 are used to change the bank register.

CY, the carry flag, this carry flag, whenever there is carry out from the D7 bit. it is affected after an 8-bit addition or subtraction operatiion.
it can also be rest to 1 or 0 directly by an instruction such as "SETB C" and "CLR C" where "SETB" stands for set bit carry and "CLR" stands for clear carry
AC, auxiliary carry flag, if there is a carry from D3 and D4 during an ADD or SUb operation, the AC bit is set; otherwise, it is cleared, it is used for the instruction to perform binary codeed decimal arithmetic
P, the parity flag, the parity flag represents the number of 1's in the accumulator register only. if the A register contains odd number of 1's, then P=1, and for even number of 1's, P is 0
OV, the overflow flag, this flag is set whenever the result of a signeed number operation is too large casusing the high-order bit to overflow into the sign bit, it is used to detect errors in signed arithmetic operations


the collection of general purpose register(R0-R7) is calld as registeer banks, which accept one byte of data(8 bits).
the bank register is a part of the RAM memory in the embedded microcontrollers. Each mircocontroller consists of various memory banks, and each bank register consists of a unique address for recongnizing the storage locatio.
by default, the 8051 microcontroller is poweered up with register bank0, and by using the program status word(PSW), we can switch to other banks. and it is used to store the program instructions. 

===
the 8051 microcontroller has a total of 128 bytes of RAM
32 bytes from 00H to 1FH locations are seet aside for register banks and the stack
16 bytes from 20H to 2F locations are set aside for bit-addressable read/write memory
80 bytes from 30H to 7FH locations are used for read and write storage; it is called as scratch pad. These 80 locations RAM are widely used for purpose of storing data and parameters by 8051 programmers


stack memory allocation in 8051 microcontroller
the stack is an area of random access meory(RAM) allocated to hold temporarily all the parameters of the variables. The stack is also responsible for reminding the order in which a function is called so that it can b reeturned correctly. Wheneeever the function is called, the parameteers and local vaiables associated with it are added to the stack(PUSH). when the function retuens, the parameteers and the cariables are removed(POP) from the stack. this is why a program;s stack size changes continuously while the program is running
the stack pointer (SP) is a CPU register, SP is used to access the stack. when wee push something into the stack memory, the stack pointer increases

the stack is a section of a RAM used by the CPU to store information such as data or memory address on temporary basis. The CPU needs this storage areae considering limited nuber of registers in CPU

as the stack is section of a RAM, there are registers inside the CPU to point to it. The register used to access the stack is known as the stack pointer register.
the stack pointer in the 8051 is 8-bits wide, and it can take a value of 00H to FFH. when the 8051 is initialized, the SP pointer in the 8051 contains the value 07H. This means that the RAM location 08 is the first location used for the stack
the storing operation of a CPU register in the stack is known as a PUSH
getting the contents from the stack back into a CPU register is called a POP

===
address mode
an addressing mode refers to how you are addressing a giiven memory locatio
-immediate addreessing mode
-direct addressing mode
-register direct addressing mode
-registeer indirect addrssing mode
-indexed addressing mode

immediate addressing mode
it is termed as immediate because 8-bit dara is transferred immediately to the accumulator(destination operand)
MOV A, #6AH
the '#' symbol before 6AH indicates that the operand is a data(8-bit). in the absence of '#', the hexadecimal number would be taken as an address

direect addressing mode
this is anotheer way of adddressing an operand, the address of the data(source data) is given as an operand
MOV A, 04H
the register bank#0(4th register) has the address 04H, When the MOV instruction is executeed, the data stored in register 04H is moveed to the accumulator. As the register 04H holds the data 1FH
we have not used '#' in direct addressing mode, unlikee immediate mode. if we had used '#', the data value 04H would have been transferred to the accumulator instead of 1FH

register direct addressing mode
in this addressing mode, we use the register name directly(as source operand)
MOV A, R4
at a time, the registers can take values from R0 to R7. there are 32 such registers. in order to use 32 registers with just 8 variables to address registeers, reegister banks are used
the instruction above is 1 byte and requires 1 cycle for complete execution, hence it saves program memory

register indirect addressing mode
in this addressing mode, thee address of the data is stored in the register as opeerand
MOV A, @R0
the value stored in R0 is the address of the actual operand value
only R0 and R1 are allowed to form a register indirect addressing instruction. in other words, the programmer can create an instruction either using @R0 or @R1. all regisrer banks are allowed

indexed addressing mode
MOVC A, @A+DPTR
MOVC A, @A+PC
FPTR has the value 01FE, where 01 is located in DPH(higher 8 bits) and FE is locateed in DPL(lower 8 bits). Accumulator ahs the value 02H. So data at location (01FEH + 02H)0200H will get transferred to the accumulator
this is a 1 byte instruction with 2 cycles needed for execution

===
a timer is a specialized type of clock which is used to measure time intervals.
a timer that counts from zero upwards for measuring time elapsed is often caled a stopwatch.
it is also a device that counts down from a specifiedd time interval and used to generate a time delay

a counter is a device that stores the number of times a particular event or process occurred, with respect to a clock signal.
it is used to count the events happening outside the microcontroller.
in electronics, counters can be impplemented quite easily using register-type circuits such as a flip-flop

===
why PLL
phase locked loop
a frequency multiplier
having a PLL. so you can generate many frequencies off the onboard RC oscillator
you can operate flexibly with no external oscillator
also can reroute the PLL to an external oscillator

example:(to save power)
	I worked on a battery-powered product which normally ran at 8 MHz, with the PLL off. However, periodically, we needed to generate much faster clocks to enable I2S streaming from an external audio chip. So, we spun up the PLL just for the few seconds where we needed those clocks, then shut it down when we were done.

example:(to redue EMC emissions)
	Some microcontrollers have an embedded programmable PLL Clock Generator allowing the usage of standard 3 to 25 MHz crystals to obtain a large range of internal frequencies (up to a few hundred MHz). By these means, the microcontroller can operate with cheaper, medium frequency crystals, while still providing a high frequency internal clock for maximum system performance. The high clock frequency source is contained inside the chip and does not go through the PCB (Printed Circuit Board) tracks and external components. This reduces the potential noise emission of the application.

===
configuration bits, fuse bits
those bits are written to the flash memory so you cant change those in the runtime
need to flash again, if you want to change those

===
char a, value: -127 to +127(1byte)
int i, value -32767 to +32767(2byte)
unsigned char ch, value: 0to 255
unsignede int i, value: 0 to 655635
long&floar available

C code: var1 = 55
assembly code:
movlw 55
movwf var1

C code: var1 = var2
assembly code:
movf var2,w
movwf var1

advantagee of C over assembly
-structured program
-logical/easier for the ehuman mind to understand/read
-easier to debug
-faster time to market
-allow the C compiler to do the grunt work in assembly

PIC MCU architecture is called harvard architecture
PIC MCU has separatee data and program buses

50mA drive capability
TRISx, direction control

Port and Latch R/W operation
write to the port or the latch have the same effect
read from latch, it reads the last value
read from port, it reads the port value on the pin itself

===
#building and running bare metal executables for ARM target using GNU tools

executable, embedded target specific machine codes

cross -compolation is a process in which the cross-toolchain runs on the host machine(PC) and creates executables that run on diffferent machine(ARM)
toolchain or a cross-compilation toolchain is a colleectiion of binaries which allows you to compole, assemble, link your applications
it also contains binaries to debug the application on the target
toolchain also comes with other binaries which help you to analyze the executables
-dissect different sections of the executable
-disassemble
-extract symbol and size information
-convert executable to other formats such as bin, ihex
-provides C standard libraries

popular tool-chains
-GNU tools(GCC, GNU's Compiler Collections) for ARM embedded processors(free and open-source)
-armcc from ARM Ltd(private limiteed company)

EABI, embeddded apploiation binary interface
compiler, linker, assembler arm-none-eabi-gcc, c
ELF file analyzer
-arm-none-eabi-objdump
=arm-none-eabi-readelf
-arm-none-eabi-nm
assemebler, arm-none-eabi-as
format conveerter, arm-none-eabi-objcopy
linker, arm-none-eabi-Id

main.c
pre-processing stage, all pre-processing directives will be resolved
-heaeder filees will be included
-Marcos will be replaced
-comments are removed
main.i
parser
translating a source fie intro assembly language
code feneration stagee
higher level language code stateements will bee converted into processor architectural level mnemonics
main.s
assembler stage
assembly level mnemonics are converted into opcodes(machine codes for instructions)
main.o relocatable object
processor architecture specific machine codees with no absolute address(relocatable)

re-locatable objecct files
linker <- .a other libraries (std and/or third party .Ex. libc)
.elf executable and debug file  
objcopy tool
.ihex intel hex format
.bin format

makefile
CC, cross compiler
CC=arm-none-eabi-gcc
MACH=cortex-m4
CFLAGS= -c -mcpu=$(MACH) -mthumb -std=gnu11 -O0
LDFLAGS= --specs=nano.specs  -T stm32_linkerScript.ld -Wl, -Map=fianl.map

all: main.o led.o stm32_startup.o final.elf

//target, dependency, recipe(followed by one TAB)
main.o:main.c
	$(CC) $(CFLAGS) main.c -o main.o 
//$^, denotes dependency
//$@, denotes target
//$(CC) $(CFLAGS) $^ -o $@

final.elf: main.o stm32_startup.o
	$(CC) $(LDFLAGS) -o $@ $^

clean:
	rm -r *.o *.elf
load:
	openocd -f board/stm32f4discovery.cfg

analyzing .o files (relocatable object files)
-main.o is in elf format(eexecutable and linkable format)
-ELF is a standard file format for object files and executable files when you use GCC
-a file format standard describes a way of organizing various elements(data, read-only data, code, uninitialized data, etc.) of a program in different sections
-thee Common Object File Format(COFF): introduced by Unix system
-Arm image Format(AIF): introduced by ARM
-SRECORD: introduced by Motorola

relocatable object file, main.o, machine code file, it doesnt contain any absolute addreesses for data and code
objdump -h a.out
objdump -d a.out
objdump -D a.out > a_log

relocate memory addressees using linker script and assigning the relocatablee address to these sections
relocatable address is decided based on the type of microcontroller or processor memory map

in every obeject file,the base address is selected as zero.
From that, the offset is counted

the startup file is responsible for setting up the right environment for the main user code to run
code written in startup file runs before main(). So, you can say startup file calls main()
some part of the startup code file is the target(processor) dependent
startup code takes care of vector table placement in code memory as required by the RAM cortex Mx processor
startup code may also take care of stack reinitialization
startup code is responsible of .data, .bss section initialization in main memory

start-up file
-create a vector table for your microcontroller .vector tables are MCU specific
-write a start-up code which initializes .data and .bss section in SRAM
-call main()

code memoory(FLASH)
unused code memory
.data(initialized global and static variables)
.rodata
.text
vector table

vector table:
exceptions and interrupt in STM32F4VGT MCU
82 IRQs(interrupt request), IRQ0-IRQ81
15 system exceptions
MSP(main stack pointer)

total memory consumed by vector table
82+15+1=98 word addressable memory locations
98*4=392 bytes

create a vector table
-create an array to hold MSP and handlers addreesses
	uint32_t vectors[]={store MSP and address of various handlers here};
-instruct the compiler not to include the above array in .data section but in a different user defined section

===
//stm32Startup.c
#include<stdint.h>

#define SRAM_START 0x20000000U
#define SRAM_SIZE (128U*1024U) //128KB
#define SRAM_END ((SRAM_START)+(SRAM_SIZE))
#define STACK_START SRAM_END

void Reset_handler(void);
void NMI_handler(void);

uint32_t vectors[] __attribute__((section(".isr_vector")))= {
	STACK_START,
	(uint32_t)&Reset_handler,
	(uint32_t)&NMI_handler
};
//  __attribute__((section(".isr_vector")))
// could also be at the end
void Reset_handler(void){}
void NMI_handler(void){}

there are 97 exceptions(15 system exceptions+82 inteerrupts)
it is not required to write handlers for all the exceptions
lets creeate a single default handler for all the exceptions and allow programmer to implement required handlers as per application requirements

compiler manual
variablee attribute
section
normally, the compiler places the objects it fenerates in sections like data and bss.
sometimes, however, you need additional sections, or you need certain particular variables to appear in special sections
for example to map to special hardware. the section attribute speecifies that a variable(or function) lives in a particualr sectiono
for example, int init_data __attribuutee__((section("INITDATA")));

in GNU C, you declare certain thing about functions called in your program which help the compiler optimize function calls and check your code more carefully
the key word __attribute__ allows you to specify special attributes when making a declaration

weak attribute
this is primaroly useeful in defining library functions which can be oveerridden in user code
alias attribute
the alias variable attribute causes the declaration to be emitted as an alias for another symbol known as an alias target

//stm32Startup.c
#include<stdint.h>

#define SRAM_START 0x20000000U
#define SRAM_SIZE (128U*1024U) //128KB
#define SRAM_END ((SRAM_START)+(SRAM_SIZE))
#define STACK_START SRAM_END

//symbol that user created
extern uint32_t end_of_text;
extern uint32_t start_of_data;
extern uint32_t end_of_data;
extern uint32_t start_of_bss;
extern uint32_t end_of_bss;

//prototype of main;
int main(void);

void Reset_handler(void);
void NMI_handler(void) __attrivute__((weak, alias("Default_Handler")));
void HardFault_handler(void) __attrivute__((weak, alias("Default_Handler")));
// ...

uint32_t vectors[] __attribute__((section(".isr_vector")))= {
	STACK_START,
	(uint32_t)&Reset_handler,
	(uint32_t)&NMI_handler
	// ...
};

void Default_Handler(void){
	while(1);
}
void Reset_handler(void){
	//copy .data section to SRAM
	uint32_t size=(uint32_t)&end_of_data - (uint32_t)%start_of_data;
	uint8_t* pDst=(uint*_t*)&start_of_data; //SRAM
	uint8_t* pSrc=(uint*_t*)&end_of_text;	//FLASH
	
	for(uint32_t i = 0; i<size; i++){
		*pDst++ = *pSrc++;	
	}	

	//init .bss section to zero in SRAM
	size =(uint32_t)&end_of_bss - (uint32_t)%start_of_bss;
	pDst = (uint8_t*0 &start_of_bss;
	for(uint32_t i = 0; i<size; i++){
		*pDst++ = 0;	
	}	

	//call init function of standard library
	main();
	//call main()
}

here "Deffault_Handler" is an alias function name for "NMI_Handler"
in the vector table array, address of "Default_Handler" function will be stored
so when NMI exception triggers, "Default_Handler" will be executed

now, we are making this weak, 
this is because, we are allowing user to override this function with same function name in main application.
there user can implement real implementation of handling that exception

===
transfeerring of .data section to RAM (C start up)

code memory (FLASH)
data memory (SRAM)

merging and address relocation done by linker and locator with the help of linker script

linker script is a text file hich explains how differeent sections of the objeect files should be merged to create an output file
linker and locator combination assigns unique absolute addresses to different sections of the output file by referring to address information mentioned in the linker script
linker script also includes the code and data memory address and size information
linkere script are writteen using the GNu linker command language
GNU linker scrupt has the file eextension of .ld
you must supply linker script at thee linking phase to the linker using -T option

linker scripts commands
ENTRY
MEMOORY
SEECTIONS
KEPP
ALIGN
AT>

Entry command
this command is used to set the Entry point address information in the header of final elf file generated
in our case, "Reset_Handler" is the entry point into the applocation
the first piece of code that executes right after the processor reset
the debugger uses this information to locate the first function to execute
not a mandatory command to use, but required when you debug the elf file using the debugger(GDB)
syntax: Entry(__symbol_name__)
	Entry(Reset_Handle)

Memory command
this command allows you to describe the different memories present in the target and their start address and size information
the linker uses information mentioned in this command to assign addresses to merged sections
the inforamtion is given under this command also helps thee linker to calculate total code and data meemory consumeed so far
and throw an error message if data, codee, heap or stack areas can not fit into available size
by using memory command, you can fine-tune various mmories available in your target and allow different sections to occupy different memory areas
typically one linker script has one memory command

syntax:
MEMORY{
	name(attr):ORIGIN=origin,LENGTH=len
}

name, defines name of the memory region which will be later refereeneced by other parts of the linker script
ORIGIN, defines irigin address of the memory region
LENGTH, defines the length inforamtion

attr, defines the attribute list of the memory region
vaild attribute lists must be made up of the characteers "ALIRWX" that match section attributes

R, read-only sections
W, read and write sections
X, sections containing executable code
A, allocated sections
I, initialized sections
L, same as I
!, invert the sense of any of the following attributes

sections command
SECTIONS command is used to create different output sections in the final elf executable generated
important command  by which you can instruct the linker how to merge the input sections to yield an output section
this command also controls the order in which different output sections appear in the elf file generated
by using this command, you also memtion the placement of a section in a memory region
for example, you instruct the linker to place the .text section in the FLASH memory region, which is described by the MEMORY command

location counter(.)
this is a special linker symbol denoted by a dot .
this symbol is calleed  "location counter" since linker automatically updates this symbol with location(address) information
you can use this symbol inside thee linker scrupt to track and define boundaries of various sections
you can also set location counter to any specific value while writing linker script
location counteer should appear only inside the SEECTIONS command
the location counteer is theen incrementede by the size of the output section

linker script symbol
a symbol is the name of an address
a symbol declaration is not equivalent to a variablee declaration what you do in your C application

symbol table
addreess|symbol
0x20000000|my_value

symbol valuees are addresses added by thee linker for your variables and functions
custom symbol values added by you by creating linker symbols in linker script


===
//stm32_linkerScript.ld
//FLASH size(KB) 1024
//SRAM1 size(KB) 112
//SRAM2 size(KB) 16

ENTRY(Rest_Handler)

MEMORY{
	FLASH(rx):ORIGIN =0x08000000,LENGTH=1024*1024
	//SRAM1(rwx):ORIGIN =0x20000000,LENGTH=116*1024
	//SRAM2(rwx):ORIGIN =0x20000000+(116*1024)-4,LENGTH=16*1024
	SRAM(rwx):ORIGIN =0x20000000,LENGTH=128*1024
}

__max_heap_size=0x400; // a stmbol declaration. not a variable
__max_stack_size=0x200; // a stmbol declaration. not a variable

SECTIONS{
	
	.text:{

		//by default, . is equal to vma which is FLASH(0x08000000
		//its gonna increase the size of .isr_vector, .text and .rodata
		*(.isr_vector)
	
		//.text of main.o led.o startup.o
		*(.text) 
		//* is wild card character. it just says merge .text sectioin of all input files

		*(.rodata)
		.= ALIGN(4)

		end_of_text =.;
		//store the updated location counteer value in to a symbol 'eend_of_text'

		//merge all .isr_vector seection off all input files
		//merge all .text section of all input files
		//merge all .rodata section of al input files	
	}>FLASH AT>FLASH

	//}>(vma)AT>(lma)
	//vma, vitural memory addreess
	//lma, load memory address

	.data:{
		
		start_of_data = . ;
		//here, the location counter resets to start of VMA of this seection, which is SRAM(0x20000000)
		//start_of_data = 0x20000000;
		
		//assgin a value to a symbol 'start_of_data'
		*(.data)	

		end_of_data = . ;

	//heere mergeee all .data section of all input files
	}>SRAM AT>FLASH
	//}>(vma)AT>(lma)

	.bss:{
		start_of_bss = . ;
		*(.bss)
		*(COMMON)
		. = ALIGN(4);
		end_of_bss = . ;
	}>SRAM

}

===
storage of final executable in code memory
codee memory(FLASH)
unused code memory
.data, initializd global and static variables
.rodata
.text
vector table

data memory(SRAM)
stack
unused SRAM
heap
.bss, un-initialized global and static variables
.data, initializede global and static variables

===
to link:
arm-none-eabi-gcc *.o -T stm32_linkerScript.ld -nostdlib -o final.elf

to create memory map file
arm-none-eabi-gcc *.o -T stm32_linkerScript.ld -nostdlib -o final.elf -Wl,-Map=final.map

unaligned access is bad
https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt
the effects of performing an unaligned memory access vary from architecturee to architecturee.
-some architectures aree able to perform unaligneed memory accesses transpareently, but there is usually a significant performance cost
-some architecture raise proceessor eexceptions when unaligned accesses happen. Thee exception handler is able to correct the unaligned access, at significant cost to performance
-some architectures are not capable of unaligned memory access, but will silently peerform a difffereent memeory access to the one that was requestede, resilting in a subtle code bug that is hard to detect

arm-none-eabi-nm final.elf
to see all the symbol

===

downloading executablee to target
host
host interface:USB
in-Circuit Programmer/Deebugger (debug adapter)
target interface:SWD ot JTAG
target

OpenOCD(Open on Chip Debugger)
OpenOCD aims to provide debugging, in-system programming, and boundary-scan testing for eembedded target devices
its if ffreee and opensource host applocation allows you to program, deebug and analyze your applications using GDB(GNU Debugger)
it supports various target boards based on different processor architcture
OpenOCD currently supports many types of debug adapters:USB-based, parallel port-based, and other standalone boxes that run openOCD internally

programming adapters
programming adapteers are used to get access to the debug interface of the target with native protocol signaling such as SWD or JTAG since Host doesnt support such interfaces
it does protocol conversion, forxamplee, commands and messages coming from host application in the form of USB packets will be converted to equivalent debug interface signaling(SWD or JTAG) and vice veersa
mainly debug adapter helps you to download and debug the code
somee advanced debug adapters will also help you to capture trace events such as on the ffly instruction trace and profiling information

===
Newlib is a C standard library implementation intended for use on embedded systems, and it is introduced by Cygnus Solutions(Red hat)
"Newlib" is written as a Glibc(GNU libc) replacement for embeedded systeems. it can be used with no OS(bare metal) ot with a lightweeight RTOS
Newlib ships with gnu ARM toolchain installation as the default C standard library

the idea of Newlib is to implement the hardwaree-independent parts of the standard C library and reely on a few low-level systeem calls that must be implemented with the target hardwaree in mind
when you are using newlib, you must implement the system calls appropriately to support devices, file-systems and memory management

printf() embedded application
Newlib-Nano, _write(); C standard library
_write(){...} printf function implemented here will receive all the strings pre formatted by printf()
_read(){...} scanf
_sbrk(){...} malloc

UART, ITM, LCD, stubs(low level target specific system implementation)


===
commProtocal

SPI
serial peripheral interface

SPI master
SPI slave

SCLK, serial clock
	means it is a synchronous interface as opposed to an asynchronous interface, like UART
MOSI, master out slave in
MISO, master in slave out
SS, slave select, active when it is low
	could have multiple SS

advantages
-full-fuplex, means can send and recieve at the same time
-higher speed than UART and I2C
-ubiquitous, loweer level than USB

disadvantages
-more pins than UART and I2C
-short distance(vs. RS-485/RS-232)
-lots of variants
	CPOL, clock polarity, if CPOL is low, the clock is low when it is idle
	CPHA, clock phase, what edge of the clock does the data go out on and does the date get sampled on
===

I2C, TWI(two wire interface)
inter-integrated circuit
I2C bus

master, SCL, SDA
slave, SCL, SDA
SCL, serial clock line
SDA, serial data line

advantages
-low pin count, only 2
-addressing built-in
-ubiquitous

disadvantages
-half-duplex, 400 kbps max(sorta)
-careeful consideration of hardware
-more complicated than SPI or UART

hardware details - "open drain"(open collector)

start init, SDA goes low,and then SCL goes low
7 addreess bits, A6 A5 A4 A3 A2 A1 A0 
R/W, 1 read, 0 write
ACK, 0 ack
8 data bits, D7 -> D0
ACK, o ack
stop, SCL goes high and then SDA goes high

if master wants to read from a slave, it reads whatever is in the buffer

resisor size(4.7k common)
10-bit addreessing possible(uncommon)
if 400kHZ is not enough, !MHz, 3.4MHz, 5MHz possible(uncommon)
multi-master possible(uncommon)
repeated start conditons possible(uncommon)
clock streching possible(slave side)


===

UART
universal asynchronous receiver/transmitter
AKA serial port, com port, RS-232, RS-485

Tx, receiver
Rx, transmitter

UART configuration parameters
-baud rate(bits per second)
	9600, 19200, 115200, others
-number of data bits
	7,8
-parity bit
	on, off
-stop bits
	0,1,2
-flow control
	none, on,hardware

start bit
bit 0, bit 1, bit 2, bit 3, bit 4, bit 5, bit 6, bit 7
(parity bit), does xor to every single bit
stop

look for falling edge if start bit
sample middle of data bits

ASCII

========
- MCU, microcontroller
  - CPU, RAM, flash storage and peripherals all on one chip
  - small, low power, low performance
  - microwave oven, washing machine, remote sensor
- MPU, mircoprocesor
  - CPU, RAM, storage and peripherals on separate chips
  - high power, high performance, high cost
  - mostly x86 architecture
- SoC, system on chip
  - MPU with on-chip peripherals
  - mostly ARM architecture

- most of MCU do not have virutal memory, even if they do not have enough RAM for linux
- minimum hardware spec
  - 32/64 bit processor architecture with MMU, memory management unit
    - ARM, x86, RISC-V
  - at least 16MB RAM
  - at least 4MD storage, usually flash memory

- BSP, board support packages
  - bootloader
  - linux kernel
  - kernel drivers specific to the board
  - device tree, ARM
  - libraries to support vendor-specific components such as accelerated graphics
  - boot scripts and run-time configuration files
  - firmware binaries for on-chip peripherals
- ARM/RISC-V BSP
  - U-boot, linux, device tree, recipes for Yocto or buildroot
- x86 BSP
  - BIOS(part of BSP/motherboard), kernel drivers for non-generic or proprietary hardware

- toolchain, to compile all the other elements
- bootloader, to initialise the board and load the kernel
- kernel, to manage system resources
- root filesystem, to run applications

========
makefile

.PHONY clean
// in case you have a file named clean
// a phony target is simplt a target that is alwayz out of date
output: main.o messgae.o // primary target
  g++ main.o message.o -o output

main.o: main.cpp
  g++ -c main.cpp

message.o: message.cpp
  g++ -c message.cpp

clean:
  rm *.o output


========
task:set of prograam instructions loaded in memory
thread:unit of CPU ultilization with its own program counter and stack
process:instance of a computer program
freeRTOS: task=thread

general purpose operating system
-task scheduling
-resource management
-device drivers

super loop
interrupt service routine(ISR)

.h->.o(object file) compile
.o(object file)-> executable file link

when compling, the complior checks syntax and function and variable declaration
pack .o files, archive file, .a 
ar cr libhello.a hello_fn.o bye_fn.o

target:prereuisites
	command	

prereuisites, files needed in order to generate target

when running, makefile would check the date of prerequisites and target files
if prerequisites file is newer than target file, make would run the following command

obejcts: test1.o test2.o
clean: rm main$(objects)

phony target
-to avoid a conflict with a file of the same name
-to improve performance
https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html

========
- BIOS is copied from ROM to RAM
- BIOS initializes HW, runs power-on self test
- BIOS searches for an OS, loads and starts the OS

# BIOS legacy booting
- BIOS loads the first sector of each bootable device into memory(at location 0x7C00)
- BIOS checks for 0xAA55 signature, if found, it starts executing code
# EFI
- BIOS looks into sepcial EFI partitions
- OS miust be compiled as an EFI program

- directive, gives a clue to the assembler that will affect how the program gets compoled. 
  - not tranlsted to machine code
- instruction, translated to a machine code instruction that the CPU will execute

Arduino
---
check if the port is in use
lsof | grep usbserial
If the port is in use, you will get a response like this (otherwise it will return nothing):
screen    27127 Sefi    5u     CHR               18,0        0t0       605 /dev/tty.usbserial
Note the session number. In my case, it's 27127. Then run:
screen -x 27127 (obviously use your session number from the grep) 
It will return you to your previous screen session. Then use ctr-A ctr-\ to close it properly (will ask you to confirm).


gcc/g++
---
-l link to the libraries that are in the default path
-L link to the libraries that are not in the default path

-I find the include header file

-o followed by the name of the output file

the default include path for gcc searches /usr/local/include
The default library path for gcc searches /usr/local/lib

#include<xxx.h> complior would find in system dir
#include"xxx.h" complior would find in user dir

CFLAGS 表示用于 C 编译器的选项，
CXXFLAGS 表示用于 C++ 编译器的选项。

LIBS：告诉链接器要链接哪些库文件，如LIBS = -lpthread -liconv
CFLAGS： 指定头文件（.h文件）的路径，如：CFLAGS=-I/usr/include -I/path/include。同样地，安装一个包时会在安装路径下建立一个include目录


pkg-config首 先在prefix/lib/pkgconfig/中查找相关包（譬如opencv）对应的相应的文件（opencv.pc）。在linux上上述路径名为 /usr/lib/pkconfig/
pkg-config --libs --cflags opencv
gcc hello.c -o hello $(pkg-config allegro-5 allegro_font-5 allegro_image-5 allegro_primitives-5 --libs --cflags)

//gcc -o sample sample.c -I allegro5/include -L allegro5/lib -l allegro -lallegro_main


tmux
---
1.% split windows left and right
2.x close current window
3.; switch between windows
4.o switch to last window
5.use the arrow key to switch between windows
6.z maximize the current window
7.c create a new window
8.& close current window
9., rename the window
10.w show all the windows
11.tmux new -s name create a new session named name
12.tmux ls
13.tmux a recover last session
14.tmux a -t name
15.tmux kill-session -t name
16.tmux kill-server
17.$ rename the session
18.s show all the sessions
19.d detach current session

===
grep is an acronym that stands for global regular expression print
grep 'string to match' 'file name'

- to search multiple files, grep 'string to match' 'file name 1' 'file name 2'
- search all files in the current directory, grep 'string to match' *
- grep commands are case sensitive use -i to ignore case in grep seaches
- to include all subdirectories in a search, add the -r operator to the grep command
- to list names of matching files, use -l

OEM, original equipment manufacturers
  - produces some original equipments
  - their forus is on degisning, promoting, assembling cars and odering from vendors

Tier 1, 2 and 3 suppliers
- Tier 1 suppliers are companies that supply parts or systems directly to OEMs
  - Tire 1 usualy work with a variety of car companies
- Tier 2, supply parts that end up in carss, they dont directly sell to OEMs.
  - they dont have the ability or desire to produce automotive-grade parts
- Tier 3, rare, raw, close to raw materials, plasti or metal

ECU, electronic control unit includes sensors, actuators, microcontrollers
CAN network
 
Microcontroller Abstraction Layer, MCAL
  makes the BSW (basic software) 
  and the application layer 
  independent of the microcontroller

- application layer
- runtime environent
- basic software
  - services layer
    - system
    - memory
    - communication
    - crypto
  - ECU abstraction layer
    - system abstraction 
    - memory abstraction 
    - communication abstraction 
    - crypto abstraction 
  - microcontrolleer abstractioin layer
  - complex drivers layer
- microcontroller

BSW modules:
- operating system
- access to non volatile memory
- communicatioin via CAN, LIN, FlexRay and Ethernet
- handling the diagnostics
- access to I/O ports
- systems services like ECU state management

MCAL, microcontrolleer abstractioin layer
- SW modules with direct access to the uC and internal peripherals
- make higher SSW layers independent of uC
- implementation: uC dependent
  upper interface: standardized and uC independent

ECU abstraction layer
- interfaces the microcontrolleer abstractioin layer
- implementationl: uC independent, ECU hardware dependent
   Uper interfacae: uC and ECU hardware independent

Complex drivers layer

Services layer, mostly uC and ECU hardware independent

RTE, AUTOSAR runtime environment
- is a layer providing communication services to the application software, AUTOSAR SW components and/or AUTOSAR sensor/actuator components
- make AUTOSAR SW components independent from the mapping to a specific ECU
- implementation: ECU and application specific (geneerated individually for each ECU)
  upper interface: completely ECU independent

Application layer, OEM would pay for this

================
legacy CAN STACK architecture

Application
CAN STACK
CAN DRIVER, hardware API
CAN HAREWARE

================
AUTomotive Open System ARchitecture
- application layer
- runtime environment, RTE
- basic software, BSW
- microconroller

========
avrdude to upload and flash code to MCU
-change fuse
-upload code
./avrdude
avrdude -C ../etc/avrdude.conf -p atmega328p -c usbtiny -U lfuse:w:0xF2:m
/applications/Arduino.app/Contents/java/hardware/tools/avr/bin
notes: delay() in Arduino waits a certain amount of clock cycles. Changing the oscillator means changing the clock speed, thus it waits a diiferent amount of time.

c code -> assembly -> machine code
compiler, assembler

avr-gcc -mmcu=atmega328p dummy.c
hexdump a.out
./a.out

----
text(code)
----
data(varible)
----
stack
|
V growth
----
free
----
^growth
|
heap
----

converts it to a hex file before upload
avr-objcopy -O ihex -j .text -j .data a.out a.hex

use avrdude to upload
avrdude -C /usr/local/Cellar/avrdude/6.3_1/etc/avrdude.conf -v -p atmega328p -c usbtiny -U flash:w:a.hex

avr-gcc compile C code to machine code
avr-objcopy translate from raw binary to "intel hex" format
avrdude upload machine code to thee microcontroller

for my redboard 
avrdude -C /usr/local/Cellar/avrdude/6.3_1/etc/avrdude.conf -v -p atmega328p -c stk500v1 -P /dev/tty.usbserial-DN02Z1QJ -U flash:w:/Users/chenshen/Desktop/FreeRTOS710-template-for-ATmega328P-master/main.hex -F

preprocessor automated copy/paste
its convention to write the keyword in ALL CAPS so other people recognize that you are using a preprocessor macro
#define FIND replace

linkers
so there is no need to recompile each library everytime
By default, avr-gcc runs the linker
We can add rhe -c flag to ddo a compile only operation.

avr-gcc -c -mmcu=<microcontroller> <sourceFile>
generates .o file

avr-gcc -mmcu=<microcontroller> <machineCode1><machineCode2><machineCode3>
generates excutable file

.h file for prototypes for functions
avr-gcc -c ... stop after compile+assemble
avr-gcc -E ... stop after preprocessor
avr-gcc -S ... stop after compile

example1:
#idndef MITCHISCOOL
#define MITCHISCOOL 1234
void delay(long)
...
#endif

example2:
#ifnddef __TIMING_H__
#define __TIMING_H__
...
#endif

bit banging(bitwise operations)
PORTB =PORTB|32 (turn one bit on)
10001010
00100000 or |
10101010

PORTB =PORTB&233 (turn one bit off)
10101010
11011111 and &
10001010

bit shifting
PORTB =PORTB<<1

PORTB |=(1<<5)
10001010
00100000 1<<5 or
10101010

PORTB &= ~(1<<5)
10101010
11011111 ~(1<<5) and
10001010 

bit banging(toggle)
PORTB =PORTB^(1<<5)
10101010
00100000 xor
10001010

10001010
00100000 xor
10101010

Turn PB5 on: PORTB |= (1<<5)
Turn PB5 off: PORTB &= ~(1<<5)
Toggle PB5: PORTB ^=(1<<5)

----
STM32
HAL layer

fake analog PWM pulse width modulation
real analog DAC digital to analog converter

duty cycle: percentage of time the pin is ON during the cycle
resolution: the number that we count to. number of possible duty cycle settings
frequency: the number of times we repeat the cycle per second

example:
system clock is 72MHZ -> we can count 72 million times each second
8-bit resolution(0-255) -> each cycle is 256 counts
the PWM frequency is 72 000 000 / 256 = 218250 cycles,218KHZ 

anode positve
cathode negative
VSS voltage source GND
VDD voltage drain

---
DDRAM:data display random access memory
 it is the working data buffer of the display
 each character on the display has a correspinding DDRAM location 
 and the byte loadeed in DDRAM controls which character is displayed
CGROM:characteer generation read only memory
 holds all the standard patterens for 5*7 dor matrix characters
CGRAM:character generation random access memory
 allows the user to define speacial supplementary non-standard character types that are enot in the CGROM
 you can load your own dot pattern shapes and call these up for display


instructions to use a LCD display
clear display
return home
entry mode set: set the moving direction of cursor and display
display on, No cursor
write data to screen

bouncing occurs for switches, addding a capacitor could solve the problem

avr-gcc -mmcu=atmega328p -c main.c
avr-gcc -mmcu=atmega328p main.o FreeRTOS/Source/tasks.o FreeRTOS/Source/croutine.o FreeRTOS/Source/list.o FreeRTOS/Source/queue.o FreeRTOS/Source/timers.o FreeRTOS/Source/extras/comtest.o FreeRTOS/Source/portable/GCC/ATMega328/port.o  FreeRTOS/Source/portable/GCC/ATMega328/extras/serial.o  FreeRTOS/Source/portable/MemMang/heap_1.o -o main
avr-objcopy -O ihex -j .text -j .data main main.hex
avrdude -C /usr/local/Cellar/avrdude/6.3_1/etc/avrdude.conf -v -p atmega328p -c stk500v1 -P /dev/tty.usbserial-DN02Z1QJ -U flash:w:/Users/chenshen/Desktop/FreeRTOS710-template-for-ATmega328P-master/main.hex -F

===
interface, is the path for communication betweeen two components.
interfacing is of two types, memory interfacing and I/O interfacing

memory interfacing
when we are executing any intruction, we need the microproceessor to access the memory for reading instruction codes and the data stored in the memory.
for this, both the memory and the microprocessor requires some signals to read from and write to registers
the intercaing process includes some key factors to match with the memory requirements and microprocessor signals. the interfacing circuit therefore should be designed in such a way that it matches thee memory signal requirements with the signals of the microprocessor

IO interfacing
there are various communication devices like the keyboard, mouse, printer, rtc. 
we need to interface the keyboard and other devices with the micropressor byusing latches and buffers. this type of interfacing is known as IO interfacing

serial communication interface
	in this type of communication, the interface gets a signal byte of data from the microprocessor and sends it bit by bit to the other system serially and vice-a-versa
parallel communication interface
	in this type of communication, the interface gets a byte of data from the microprocessor and sends it bit by bit to the other systems in simultaneous or paralleel fashion and vice-a-versa
===
8051, it is an 8-bit microcontroller. it is built with 40 pins DIP(dual inline package), 4kb of ROM storage and 128 bytes of RAM storage, 2 16-bit timers. An on-chip verystal oscillator is intergrated in th microcontroller having crystal freequency of 12MHZ

the system bus connects all the support devices to the CPU.
the system bus consists of an 8-bit data bus, a 16-bit address bus and bus control signals. all other devices like program memory, ports, data emmory, serial interface, interrupt control, timers and the CPU are all interfaced together through the system bus

Pin 29: PSEN, program store enable, it is used to read a signal from the external program memory
Pin 30:EA, external access input, it is used to enable/disable the external memory interfacing
Pin 31:ALE, address latch enable, it is used to demultiplex the address-ddare signal for port

===
assembling a program
the host system and the tarfet system is different
specify how to transform the source code into machine code, where to locate the machine code in the target system memory, how to load the program from the host system into the target system

the final program that runs on the MCU target computer is called an executable program or simply an "executable"
1. create an assembly progtram(.asm or .s)
2. an assembler which converts the source code into a binary form suitable for the MCU(croess-assembler). The assembler generates an object file that hasa .o extension can contains what people call object code. 
the object file is in a format called an ELF(extensible linking and format)/DWARF(is also a standard file fomat for the information generated bu compilers, assemblers and linkers) format, and in addition to machine code, it has a certain amount of overhead data
3. the .o file created bu the assembler is an intermediate file that has the essential MCU machine language, but it still needs to be modified somewhat.
for instance, it may need to be combined or linked with other object code files, such as library routines, to create the final profram that will actually run on the microcontroller. it may also need to resolve addresses which are not known unitl other files are linked with it.
	the job of the linker is to create a complte machne code file that is almost ready to run on the MCU. the linker does this by filling in the unresolved addreesses and by linking related programs to create the final program.
	the file created by the linker is called an absolute file and has a .abs file extension. the absolute file contains the executable machine code that will be used by the MCU, and it also has overhead information such as address assignments for the code, etc. the .abs file that we generate with the linker is sometimes called an executablee image since it has all the esstential machine code but doesnt yet sit on the target system. this executable image will be transferred to the MCU after one more transformation
 the .abs file that we generate with the linker is sometimes called an executablee image since it has all the esstential machine code but doesnt yet sit on the target system. this executable image will be transferred to the MCU after one more transformation the .abs file that we generate with the linker is sometimes called an executablee image since it has all the esstential machine code but doesnt yet sit on the target system. this executable image will be transferred to the MCU after one more transformation the .abs file that we generate with the linker is sometimes called an executablee image since it has all the esstential machine code but doesnt yet sit on the target system. this executable image will be transferred to the MCU after one more transformation the .abs file that we generate with the linker is sometimes called an executablee image since it has all the esstential machine code but doesnt yet sit on the target system. this executable image will be transferred to the MCU after one more transformation
4. in the next step, we convert the absolute .abs file into a form suitable for a loader to use.
the loader is a program that will transfer the executable program from the host system to the target system. the loader requires that the executable machine code inforamtion in the .abs file be formatted in a ceratin way. we do this by converting the executablee machine code information in the .abs file into short chunks of code, called "S-records" by Motorola.
each S-record is a line of text containing a header, the address where the machine code will be loaded, the machine code itself, and some extra checksum bits to make sure that the transfer was successful.
the final program that we will download to the MCY consists of a bunch of these S-reords in one file which has a file exteenskon ".s1" or ".sx"
5.finally, we must transfer the .s1 file from the host PC to the target MCU. this is done using a program called a loader. There are serveeral tyoes of loaders depending on the connection between the host system and the target system, and depending on the format of the file to be transferreed.

===
backdooring hardware devices by injecting malicious payloads on microcontrollers
https://www.youtube.com/watch?v=s326a_HELuw&ab_channel=HackersOnBoard

mircroprocessors, Intel, AMD, ARM
microcontrollers, microchip, ATMEL, ST

microprocessors overview
- microprocessors = CPU
- memories and I/O busses are physically separated
- usually bigger than a microcontroller
- greater processing capacity
- input -> microprocessor(ALU, registers, etc) -> output
								^
								|
								v	
							memory	
- modified-harvard memory organization
- 32 or 64 bits(most common)	

mircrocontrollers overview
- microcontrollers = CPU + RAM + ROM + I/O busses
- smaller CPU with less processing capacity
- usually smaller size than microprecessors
- CPU, internal oscillator, RAM, ROM, peripherals, I/O busses, others
- harvard memory organizatiojn
- 16 bits (most common)
- a little stack

Raspberry PI, ARM microprocessor
Arduino UNO, atmega microcontroller

microcontrollers programming
user -> 		C file						hex file	
|							|									|
v							v									V
ASM file <- compiler					programmer software
|																|
v																v
assembler -> hex file					programmer hardware => uC

PIC program memory dump
- program memory, non-volatile
- data memory (RAM), SFR(special function registers), GPR (general purpose registers), volatile
- data flash/ EEPROM memoty (ROM), non-volatile

PIC program standard structure
# include files
PIC config directives
program constants
RAM variables
resert vector 0x0000; goto start, reset vector: always at 0x0000 memory address
interrupt vector 0x0008, interrupt vector: at 0x0008 and 0x0018 memory address
	interrupt routine #1
	interrupt routine #2
start: , program entry pointo
	program main code
	
ASM source code:
REST_VECT CODE 0x0000
	GOTO START

; TODO add interrupts here is used

MIAN_PROG CODE

START
	CLRF PORTD	; clear PORTD
	MOVLw B'00000000'
	MOVWF TRISD ; set all to output

	BSF PORTS,2	; turn on LED
	GOTO $	; loop forever

END

disassembly:
line address opcode disassembly
1			0000		EF03	GTO 0x6
2			0002		F000	NOP
3 		0004		0000	NOP
4			0006		6A83	CLRF PORTD,access
5			0008		0E00	MOVLW 0x0
6 		000A		6E95	MOVWF TRISD, access
7			000C		8483	BSF PORTD, 2, access
8			000E		EF07	GOTO 0xE
9 		0010		F000	NOP
* access word, data access memeory is performed, because PORTD and TRISD are SFR located at RAM

opcodes in the .hex dump
: 020000040000FA
: 1000000003EF00F00000836A000E956E838407EF13
: 1000100000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE
: 10002000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
: 10003000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFD0
* match the assembly instructiuon in opcodes, however, they are inverted, because of the little endian format to store bits in memory
* entry point: 0x06, memory address to inject

generating the payload, malicious
BCF TRISD,1 // set pin as output
BSF PORTD,1 // turn on a LED
BCF TRISD,2 // set pin as output
BSF PORTD,2 // turn on a LED
* use the specific assembly instruction set for the target device
* in order to get the opcode, writing all the assembly instructions of the payload in an assembly file inside MP lab IDE and then compile it to get the disassembly view and get the opcodes

0000 NOP
9295 BCF TRISD, 1, access
8283 BSF PORTD, 1, access
9495 BCF TRISD, 2, access
8243 BSF PORTD, 2, access
0000 NOP
Little Endian: 0x9592 0x8382 0x9594 0x8384

exmaple, entry point at 0x28
line address opcode disassembly
1			0000		EF14	GOTO 0x28
2			0002		F000	NOP
3			0004		0000	NOP

original program memory(.hex dump)
: 02 00 00 04 00 00 FA
: 10 00 00 00 14 EF 00 F0 00 00 0E 0E 04 6E 48 0E 07 6E 50 0E 46
: 10 00 10 00 09 6E 04 00 09 2E 0A EF 00 F0 07 2E 07 EF 00 F0 2A
: 10 00 20 00 04 2E 05 EF 00 F0 00 0C 00 0E 95 6E 83 8C 03 EC 9F
: 10 00 30 00 00 F0 83 9C 03 EC 00 F0 16 EF 00 F0 FF FF FF FF E1
* 0C is the entry point offset
* end of every line, there is a checksum, 46, 2A, 9F, E1

payload injected at entry point (ox28)
: 02 00 00 04 00 00 FA
: 10 00 00 00 14 EF 00 F0 00 00 0E 0E 04 6E 48 0E 07 6E 50 0E 46
: 10 00 10 00 09 6E 04 00 09 2E 0A EF OO F0 07 2E 07 EF 00 F0 2A
: 10 00 20 00 04 2E 05 EF 00 F0 00 0C 95 92 83 82 95 94 83 84 9F
: 10 00 30 00 00 0E 95 6E 83 8C 03 EC 00 F0 83 9C 03 EC 00 FD E1
: 10 00 40 00 16 EF 00 F0 FF FF FF FF FF FF FF FF FF FF FF FF C0
* need to recaluculate the checksum

checksum recalculation
- Sum(bytes on the line) = Not + 1 = checksum
- exmaple: :1000000003EF00F00000959E838E836A000E956E
	10 + 00 + 00 + 00 + 03 + EF + 00 + F0 + 00 + 00 + 95 + 9E + 83 + 8E + 83 + 6A + 00 + OE + 95 + 6E = Ox634
	Not(0x634) +1 = 0xFFFF 0xFFFF 0xFFFF 0xF9CC
	checksum = 0xCC

paylay injected and checksum fiexed
: 02 00 00 04 00 00 FA
: 10 00 00 00 14 EF 00 F0 00 00 0E 0E 04 6E 48 0E 07 6E 50 0E 46
: 10 00 10 00 09 6E 04 00 09 2E 0A EF OO F0 07 2E 07 EF 00 F0 2A
: 10 00 20 00 04 2E 05 EF 00 F0 00 0C 95 92 83 82 95 94 83 84 52
: 10 00 30 00 00 0E 95 6E 83 8C 03 EC 00 F0 83 9C 03 EC 00 FD C3
: 10 00 40 00 16 EF 00 F0 FF FF FF FF FF FF FF FF FF FF FF FF C7

INTCON, a readable and writeable register which contains the various enablee bits for all interrupt sources
GIE EEIE TMR0IE INT0IR RBIE TMR0IF TMR0IF INT0IF RBIF
- interruptions enabled
	BSF INTCON, GIE
	BSF INTCON, EEIE
- GIE, the flobal interrupt enable bit
	EEIE, EE wrtie complete interrupt enable bit
  TMR0IE, timer0 interruption enabled
	TMR0IF, timer0 interruption flag
- multiple peripheral interrupt enable registers (PIE1, PIE2)	
	they have interruption enabling bits and interruption flags bits

example:
	address opcode disassembly
	000E		BA9E		BTFSC PIR1, 5, access
	0010		EC24		CALl 0x48, 0

	* bit 5 in PIR1 (peripheral interrupt request) is RCIF
	* communication peripherals when the microcontrollers receives datafrom any communication protocol it wil trigger an interruption that will set this specific flag to one.
	* if this flag is to one, the call will be executed jumping to a core routine located at 0x48	

	cook a payload that makes a relaying of the received data to a TX peripheral which we are able to monitor externally
	MOVF RCREG, W //move the received data to W register
	BSF	TXSTA, TXEN	// enable transmission
	BCF TXSTA, SYNC // set asynchronous operation
	BSF RCSTA, SPEN // set TX/CK pin as an output
	MOVWF TXREG	// move received data(in W) to TXREG to be re-transmitted
	opcode:
	50AE
	8AAC
	98AC
	8EAB
	6EAD
	with little endian: AE50AC8AAC98AB8EAD6E

example:
address opcode disassembly
0014		B4F2		BTFSC INTCON, 2, access
0016		EC27		CALl 0x4E, 0
0018		F000		NOP
001A		BC9E		BTFSC PIR1, 6, access
001C		EC2B		CALl 0x56, 0 
001E 		F000		NOP
0020		B2F2		BTFSC INTCON, 1, access
0022 		EC2B		CALl 0x5E, 0
0024		F000		NOP

- 0x48 to inject a payload at the RC interruption
- 0x4E to inject a payload at timer0 interruption
- 0x56 to inject a payload at the AD interruption
- 0x5E to inject a payload at the INT0 interruption

fixing jumps, flow corruption
call 0x10, and 0x10 is changed after payload injection

GOTO opcode 0xEF
CALl opcode 0XEC
NOP opcode 0xF0
* in PIC18 microcontrollers, the assembly instructions are 16 bits in length
* 8 bits are used for the opcode and 8 bits for the memory address to jump or goto
* but 2 more bytes are reserved in case of needing jumo in more than 2255 positions.
EF06 F000 = GOTO jumping to 0x0006 offst (0x000C = 0x0006 * 2 memory address)
EC67 F004 = CALl jumping to 0x467 offset (0x08CE = 0x0476 * 2 memory address)

fixing jump, recalculation
payload injected at memoty address: 0x48
paylaod length: 10 bytes
emample:
	call 0x56 (EC2B F000) -> original jump
	call 0x60 (EC30 F000) -> fixed jump, original offset + payload length
	10 bytes = 80 bits = 10 memeory address, 10 /2 = 5. 2B + 5 = 30

stack payload injection, controlling program flow
STKPTR, stack pointer register
TOSU, TOSh, TOSL, top of stack registers

top of stack 001A34h 00010
						 000D58h 00001
TOSU 00h, TOSH 1Ah, TOSL 34h
stack pointer STKPTR 00010 <4:0>

INCF STKPTR, F //SP increment
MOVLW 0x00
MOVWF TOSU // TOSU = 0x00
MOVLW 0x0C
MOVWF TOSH // TOSH = 0x0C
MOVLW 0x72
MOVWF TOSL // TOSL = 0x72
RETURN
jump to 0x000C72

===
microprocessor

microprocessor is a controlling unit of a micro-computer, fabricated on a small chip capable of performing ALU(arithmetic lofical unit) operations and communicating with the other devices connected to it.

microprocessor consists of an ALU, register array, and a control unit.
-ALU performs arithmetical and logical operations on the data received from the memory or an input device.
-register array consists of registers identified by letters like B, C, F, E and accumulator
-the control unit controls the flow of data and instructions within the computer

fetch, decode, execute

initially, the instructions aree stored in the memory in a sequential order
the microprocessor fetches those instructiions from the memory
then decodes it and executes those instructions till STOP instruction is reached
later, it sends the result in binary to the output port
between these processes, the register storees the temporarily data and ALU performs the computing functions

instruction set, it is the set of instructions that the microprocessor can understand
bandiwidth, it is the number of bits processed in a single instruction
clock speed, it determines the number of bits processed in a single instruction
word length, it depends upon thee width of internal data bus, registers, ALU. eetc. An 8-bit microprocessor can process 8-bit data at a time. The word length ranges from 4 bits to 64 bits depending upon the type of the microcomputer

some of the most prominent features of any microprocessor
-cost effective, the microprocessor chips are available at low prices and results its low cost
-size, the microprocessor is small size chip, hence is portable
-low power consumption, microprocessors are manufactured by using meetaloxide semiconductor technology, which has low poweer consumption
-versatility, the microprocessors are versatile as we can use the same chip in a number of applications by configuring the software program
-reliablity, the failure rate of an IC in microprocessors is very low

===
RISC stands for reduced instruction set computer
it is designed to reduce the execution time by simplifying the instruction set of the computer
using RISC processors, each instruction requires only one clock cycle to execute results in uniform execution time
this reduces the efficiency as there are more lines of code, hence more RAM is needed to store the instructions.
the compiler also has to wotk more to convert high-level language instructions into machine code
some of the RISC processors are:
power PC:601, 604, 615, 620
DEC Alpha:210642, 211066, 21068, 21164
MIPS:(R100000) RISC processor
PA-RISC:HP 7100LC

architecture of RISC
RISC microproceessor architecture uses highly-optimiized set of instructions, it is used in portable devices like apple ipod dudee to its power efficiency

characteeristics of RISC
-it consists of simple instructions
-it supports carious data-type formats
-it utilizes simple addressing modes and fixed length instructions for pipelining
-it supports reegister to use in any context
-one cycle execution timee
-"LORD" and "STORE" instructions are used to access the memory location
-it consists of larger number of registers
=it consists of less number of transistora

===
CISC, stands for complex instruction set computer
it is designed to minimize the number of instructions per program, ignoring the number of cycles per instruction
the emphasis is on building compleex instructions directly into the hardware

the compiler has to do very littlee work to translate a high-level language into assembly level langue/machine code because the length of the code is relatively short, so very little RAM is reequired to store the instructions

some of the CISC processors are
IBM 370/168
VAX 11/780
Intel 80486

its architecture is designed to decrease the memory cost becuase more storage is needed in larger programs resulting in higher memory cost. To resolve this , the number of instructions per program can be reduced by embedding the number of operations in a signle instruction

characteristics of CISC
-varity of addressing modes
-larger number of instructions
-variable length of instruction formats
-several cycles may be required to execute one instruction
-instruction-decoding logic is complex
-one instruction is required to support multiple addressing modes

===
special processor, theree are the processors which are designed for some special purposes.

coprocessor
a coprocessor is a specially designed microprocessor, which can handle its particular function many times faster than the ordinary microprocessor
for example, math coprocessor
some Intel math-coprocessors are
8087-used with 8086
80287-used with 80286
80387-used with 80386

input/output processor
it is a specially designed microprocessor having a local memory of its own, which is used to control I/O devices with minimum CPU involvement
for example, DMA(direct memory access) controller
	keyboard/mouse controller
	graphic display controller
	SCSI port controller

Transputer(transistor computer)
a transputer is a specially designd microprocessor with its own local memory and having links to connect one transputer to anotheer transputeer for inter-processor communications. 
It was first deisgned in 1980 by lnmos and is targeted to the utilization of VLSI(veery large0scale integration) technology
a transputeer can be used as a single processor system or can be connected to external links, which reduces the construction cost and increases the performance.

DSP(digital signal processor)
the processor is specially designed to process the analog signals into a figital form.
this is done by sampling the voltage level at regular time intervals and converting the voltage at that instant into a figital form.
this process is performeed by a circuit callede an analogue to digital converter, A to D converter or ADC
A DSP contains the following components
-program memory, it stores the programs that DSP will use to process data
-data memory, it stores the information to be processed
-compute engine, it performs the mathematical proceessing, accessing the program from the program memory and the data from the data memory
-input/output, it connects to thee outside world
its applications are
-sound and music synthesis
-audio and video compression
-video signal proceessing
-2D andd 3D graphics acceleration
for example, texas instrument;s TMS 320 series, e.g. TMS320C40, TMS320C50

===
8085 microprocessor functional units
-accumulator
	it is an 8-bit register used to perform arithmetic, logical, I/O & LOAD/STORE operations. it is conneected to internal data bus &ALU
-arithmetic and logic unit
	it performs arithmetic and logical operations like addition, subtraction, AND, OR, etc. on 8-bit data
-general purpose register
	there are 6 geneeral purpose registers in 8085 processor, i.e.B,C,D,E,H,L. each register can hold 8-bit data
	these registers can work in pair to hold 16-bit data and their pairing combination is like B-C, D-E,H-L
-program counter
	it is a 16-bit register used to store the memory address location of the next instruction to be executed. Mircroprocessor increments the program whenever an instruction is being executed, so that the program counter points to the memory address of the next instruction that is going to be executed
-stack pointer
	it is also a 16-bit registeere works like stack, which is always invremented/decremented by 2 during push&pop operstions	
-temporary register
	it is a 8-bit register, which holds the temporary data of arithmetic and logical operations
-flag reegisteer
	it is an 8-bit reegister having five 1-bit flip-flops, which holds either 0 or 1 depending upon the result stored in the accumulator
	these are the set of 5 flip-flops
	sign(S)
	zero(Z)
	auciliary carry(AC)
	parity(P)
	carry(C)	
-instruction regiser and decoder
	it is an 8-bit register. When an instruction is fetched from memory then it is stored in the instruction register. Instruction decoder decodes the information present iin the instruction register.
-timing and control unit
	it provides timing and control signal to the microprocessor to perform operations. 
	following are the timing and control signals, which control external and internal circuits
	control signals: READY, RD, WR, ALE
	status signals: S0, S1, IO/M
	DMA signals: HOLD, HLDA
	reset signalsL RESET IN, RESET OUT
-interrupt control
	it controls the intrrupts during a process.
	when a microprocessor is executing a main program andd whenever an interrupt occurs, the microproceessor shifts the control from the main program to process the incoming request. after the reequest is completed, the control goes back to the main program
	there are 5 interrupt signals in 8085 microproceessorL INTR, RST 7.5, RST 6.5, RST 5.5, TRAP
-serial input/output control
	it controls the serial data comunication by using these two instruction SIC(serial inout data), and SOD(serial output data)
-address buffer and address-data buffer
	the content stored in the stack pointer and profram counter is loaded intothe address buffer and address-data buffer to communicate with CPU. 
	the memory and I/O chips are connected to these buses.
	the CPU can exchange the deesired data with the memory and I/O chips
-address bus and data bus
	data buses carries the data to be stored. it is bidirectional
	address buses carries the location to where it should be stored and it is unidirectional

addressing modes in 8085
there are the instructions used to transfer the data from one register to another register, from the memory to the refister, and from the register to the memory
-immediate addressing mode
	in this mode, the 8.16 bit data is specified in the instruction itself as one of its operand. For example: MVI K, 20F: means 20F is copied into register K
-register addressing mode
	in this mode, the data is copied from one register to another. For example: MOVE K, B:means data in reegister B is copied to register K.
-direect addressing mode
	in this mode, the data is directly copied from the given address to the register. For exampkle: LDB 500K:means the data at address 5000K is copied to register B
-indirect addressing mode
	in this mode, the data is transferreede from one register to another by using the address pointed bu the register. For example: MOV K,B:means data is transferred from the memory address pointed by the register to the register K
-implied addressing mode
	the mode doesnt require any operand; the data is speecified by the opccode itself. For example:CMP

interrupts in 8085
inteerrupts are the signals generated by the external devices to request the microprocessor to perform a task
-vector interrupt
	in this type of interrupt, the interrupte address is known to thee processor
-non vector interrupt
	in this type of interrupt, the interrupte address is not known to thee processor, so the interrupt needs to be sent externally by the device to perform interrupts
-maskable interrupt
	in this type of interrupt, we can disable the interrupt by writing some instructions into the program
-non maskable interrupts
	in this type of interrupt, we can not disable the interrupt by writing somee instructions into the program
-software interrput
	in this type of interrupt, the programmer has to add the instructions into the program to execute the interrupt
-hardware interrupt

INTA is not an interrupt, it is used by the microproceessor for sending acknowledgement

interrupt service routine(ISR)
a small program or a routine that when executed, services the corresponding interrupting source

===
8086 is an enhaced version of 8085

8086 microprocessor is divideed into two functonal units
EU(execution unit)
BIU(bus Interface unit)

===
multiprocessor 
multiprocessor mmeans a multiple set of processors that executes instructions simultaneously
there aree three basic multiprocessor cconfigurations
-coproceessor configurations
-closely coupled configuration
-loosely coupled configuration

===
# AVR
- interrupt vector table
  - located in FLASH memory
  - starts at 0x0000
  - 0000 reset
  - 0002 external interrupt. pin16
  - 000c watchdog timeout
  - 0024 UART/serial receive/complete
- interrupt occurs
  - check if it is enabled
  - store PC on the stack
  - load PC from the interrupt vector
  - RETI, return from  interrput
    - pop PC from stack
    - set "I" bit, back to interrupt enable 
- bootloader on board receieves the executable and writes it to flash
- servor motor
  - analog, vary the voiltage
  - PWM
    - cycle time 20ms(50HZ)
    - pulse width 0ms = 0%, 20ms = 100%

oscilloscope
provides a visual display of electrical signals and how they change over time

binwalk+IDA+qemu

squashfs

du -h

===
binwalk setup.exe                         
dd if=setup.exe of=test bs=1 count=7615744 

binwalk -e DCH-S150A1_FW101B10.bin

file ls 
ls: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped


===
strutureed binary files 
*ACSII,unicode
*portable executable(PE) file format
	PE file format is used by microsoft windows to load compiled binaries, such as EXEs, DLLs, systeem drivers.etc, into RAM and run the code found within

file signatures
*.zip starts with KP
docs + file, to see the file format

PE file format
A PE file starts with a MZ signature
because it is made up of two separate executables
*a MS-DOS executable stub,
	a leftover from the windows 95 days when programs might include both a MS-DOS runtime and a win32 runtime in the same executable
*the main PE runtime



universal asynchronous receiver transmitter
A uart can implement RS232, but it can also implement other serial protocols
RS-232 sereial communication standard
25 pin conneeector/ 9 pin conneector 
starndardized the voltage level at each pin
logical 0 iis between 3 volts and 15 volts
logical 1 iis between -3 volts and -15 volts
each pin tolerateees a shortage with any other pin of the interface without  any permanent damage
some frive chip is used to convert TTL(transistor to transistor) logic level where 0 is 0 volt and 1 is at VCC to rs-232 levels

RX,TX,GND

during a boot, a lot of information will be printeede to serial interface(word interface) for testing and deveelopment purpose
which means TX pin would oscillate betweeen 0 and 1

test resistance of each pin refereence to ground and VCC 
and power up the device test volatge of each pin

to comfirm we have corrctly indentified the  pinout of the serial intereface(word interface), we have to connect the serial interface to out PC using a terminal emulator. we need a USB TTL serial adapter

screen command 
ctrl-a k, to kill 
try one of the common baud rate

find UART
search on internet
labeeled on PCB
find candiidates
use a multi-meter
follow PCB traces
use jtagulator
logic analyzer


JATG
is an industry standard, usually implementeede in complex integrated circuits
was issued for the first timee in 1990, with the purpse to simplify the testing of PCB after manufacture
it allowed controllability and observability of eeach bit of internal memeory of each  inteegrated circuit
and allowed to check the integrity of each single trace connecting differeent integrated circuits in the PCB
controllability is the aboloty to easily ser, to zero or to one, ech internal bit of memory of an integrated circuit to check that none of them is stuck ar zero or one
observability is the ability to easily check the value of each internal bit of memory or register
it is achieved using additional circuitry and specialized long shift registers
a side effect of this purpose is the possibility to read and write the flash memory content
in-circuit debugging means being able to run a debugger on the real firmware running on the real hardware

TCK, test clock
TDI, test data in
TDO, test data out
TMS, test mode select
TRST, test reset

JTAG in hacking
read.write EEPROM
break into the boot cycle

interface board, bus pirate/but blaster etc.
JTAG software, openOCD

the quest for JTAG
seatch on internet
search labels on PCS, like TCK, TDI, TDO, TMS
no standardizeed connectors and pin-out
few popular pinouts
jtagtest.com/pinouts
pin headers candidates
	row 5/6 pins, double row 10,12,14,20 pins
use a multi-meter
	finding GND and VCC  is easy
	TMS and TDII have a pullup resistor
	TRST can usually have a pull up or pull down resistor
	RDO should be an high impedance input
follow PCB traces
JTAgulator

why JTAG is not working
missing TRST pull-up
missing resistors
anothere function on JTAG pin
JTAG software disabled
JTAG peremanently disabled

Emulation environment
CPU architecture
similar board
QEMU: quick emulator
	System Mode
	User Mode
	Vitualization Mode	

QEMU User Mode
Binary file CPU
file bin/assistant
bin/assistant: ELF 32-bit LSB executable,MIPS32 

qemu-mips[tab]
choose qemu-mipsel, el stand for littlee endian


===
JTAG, Joint Test Action Group
test access port and boundary-scan architecture
TCK, test clock
TMS, test mode select
TDI, test data input
TDO. test data output

the bus is used as a test bus for Boundary-Scan of ICs, as in deign-for-testability(DFT)
to use JTAG, during the design, you most select JTAG compatible devices.
ICs supporting JTAG will have thee ffour additional pins listed above
in addition to having the pins listed above each device most have a Boundary-Scan Register.
theBoundary-Scan reigster may be eused to test the inteerconnection betweeen ICs or test with in the IC
Boundary-scan tests can be useed to check continuity between devices.
Continuity checks on PWB(printed wiring board) nets may be performed by sending out a know pattern and reciving that same pattern at the input to another IC(s)
Not receiving thee test signal or patteern would indicate a broken PWB tracee, a failed IC, or cold solder joint

===
CC1110Fx/CC1111Fx, low poweer SoC(System-on-chip) with a 1Ghz RF transceiver

GoodFET, is an open-source JTAG adapter(universal serial bus interface)

FCC ID on the back of a phone, which tells what frequencies it transmits to
my black iphone7: BCG-E3085A
An FCC ID is the product ID assigned by the FCC to identify wireless products in the market

ISM(industrial scientific medical band), unlicensed, maximum output power is 30dBm(1 watt)

RF transmitter using ASK modulation technique(amplitude shift keying)

.wav file, using audacity to edit

===
the differences between a microcontroller and a microprocessor
- a microcontroller is microprocessor (a.k.a CPU core or cores) with additional peripherals on-chip
- those therms come from the 1970s,
	- where a microprocessor, eg, Motorola 5800 or Intel 8086
		would have an address bus, a data bus, and control lines
	- and a microcontroller, eg, Motorola 6801 or Intel 8051 
		would have peripheral I/O pins serial ports, parallel I/O. timer I/O, etc.
		but no external memory bus (you were stuck with what was on the chip)
- microprocessors executed their programs from external ROM 
	and microcontrollers would use internal masked (as in programed at the factory by changing the IC photo mask) ROM	
	the only practical erasable ROMs were UV-erased EPROMS, 
	electrically erasable PROMS(EEPROMS) were expensive, slow, and not very dense


* the line between them is fading away
*	modern microcontrollers such as the Motorola 6812 series have an external memory bus and peripheral I/O pins at the same time, and can be used as either a microprocessor or microcontroller
* spi or i2c falsh or memory

* flash, a special typoe of memory that works like both RAM and ROM.
* you can wrtie information to flash memory, like you can with RAM, but that information isnt erased when the power if off, like it is with ROM

===
RAM:
- stack (local varianles placed in stack) 
- all global variabless
- functions that specificied with special keyword ( for example, __ramfuc for IAR) as runned from RAM

SRAM, static RAM:
- SRAM is very fast and the fastest storage device to read and write currently
- it is also very expensive, so it is only used in demanding places, such as the first and second level buffer of CPU

DRAM, dynamic RAM:
- DRAM keeps data for a short time and its operation is slower than the SRAM, but it is still faster than the ROM
- in addition, it's much cheaper than SRAM
- DRAM is divided into many kinds
		- FPRAM (fast page RAM), EDORAM, SDRRAM, DDR, RAM, RFRAM and so on
* the so-called "dynamic RAM" in dynamic memory refers to when we write data to the DRAM, 
*	atfer a period of time, the data would be lost, so we need an extra circuit to refresh the memory

types of ROM:
- PROM, programmable ROM
	is programed once that can not be modified, this is an early product, now it is gone
- EPROM, erasable and programmable ROM
	is a kind of universal memory that erases the original program by ultraviolet radiation
- EEPROM, electronically erassable and programmable ROM
	- expensive, long writing time

flash:
- flash memory combines the adcantages of ROM and RAM, it has EEPROM, but also can read data quickly without power lost (NVRAM)
-	NOR flash and NAND flash
- all functions (no differents where it's will run)
- all constants
- variables iniitialization values
* for AVR, you neeed to use keyword PROGMEM to place any constant to flash (funtions dont need that), while for ARM keyword const will be enough

inside an embedded edvice is a printedd circuit board (PCB) includes
- processsor
	central processing unit, CPU
	a processor would embedded inside a system-on-chop (SoC)
- volatile memory
	volatile memory usually implemented in dynamic RAM (DRAM) chips in discrete packages
	volatile memory is the memory that the processor uses while it's in action	
	its contents are lost when the device powers down
	DRAM memory operates at frequencies close to the processor frequency
	and it needs wide bues in order to keep up with the processor
- nonvolatile memory
	nonvolatile memory is where the embedded device stores data that needs to persist after power to the device is removed
	this memory storage can be in the form of EEPROMS, flash memory, or even SD cards and hard drives
	nonvolatile memory usually contains code for booting as well as stored applciations and saved data
- analog components
	such as resistors, capacitors, and inductors 
- external interfaces
	external interfaces provides the mean sfor the SocC to make connection to the outside world
	the interfaces can be connected to other commerical off-the-shelf (COTS) chips as part of the PCB system interconnect
		- a high-speed bus interface to DRAM 
		* USB and PCI Express (PCIe) are examples of hjigh speed interfaces that connect devieces externally
		- a low-speed interfaces, such as I2C and SPI to a sensor
		
===
miniaturization allows an SoC to have more intellectual property (IP) blocks		
an exmaple of an Intel Skylate SoC
this die contains multiple cores, including the main CPU cores, the Intel Converged Security and Management Engine (CSME), the GPU and much more.
internal buses in an SoC are harder to access than external buses, making SoCs an inconvenient starting point for hacking

SoCs can contain the following IP blocks:
-	several (micro)processor and peripherals
		for instance, an application processor, a crysto engine, a video accelerator, and the I2C interface driver
- volatile memory
		In the form  of DRAM ICs stacked on top of the Soc, SRAMS or register banks
- nonvoltile memory
		- In the form of on-die read-only memory (ROM), one-time proframmable (OTP) fuses, EEPROM, and flash memory
		- OTP fuses typically encode critical chip configuration data, such as identity information, lifecycle stage, and anti-rollback versioning information
- internal buses
		the internal buses could be susceptible to spoofing, sniffing, injection, and all other forms of man-in-the-middle attacks.

software is a structured collection of CPU instructions and data that a processor executes
embedded devices can contain some of the following types of software:
- initial boot code
		- the initial boot code is the set of instructions a processor executes when it's first powered in
		- the initial boot code is generated by the processor manufacturer and stored in ROM
		- the main function of the boot ROM code is to prepare the main processor to run the code that follows
- bootlaoder
		- the bootlaoder initializes the system after the boot ROM executes
		- it is typically stored on nonvolatile but mutable storage, so it can be updated in the field
		- the PCB's original equipment manufacturer (OEM) generates the bootloader, allowing it to initilaized PCD-level components
		- it may also optionally lock down some security features in addition to its primary task of loading and authenticating an operating system or trusted execution environment (TEE)
		- the bootlaoder may provide functionality for provisioning a device or debugging
		- being the earliest mutable code to run on a device, th ebootlaoder is an attractive target to attack, less-secure devices may ahve a boot ROM that doesnt authenticate the bootlaoder, allwoing attacks to repalce the bootladoer code easily
			- bootloaders are authenticated with digital signatures, which are typically verified by embedding a public key )or the hash of a public key) in the booot ROM or fuses, because the public key is hard to modify, it's considered the root of trust.
			- the manufacturer signs the bootloader using the private key associated with the public key, so the boot ROM code can verify and trust that the manufacturer produced it.
			- once the bootloader is trusted, it can, in turn, embed a public key for the next stage of code and provide trust that the next stage is authentic. This chian of trust can extend all the way down to application running on an OS
			- theoretically, creating this chain of trust seems pretty secure, but the scheme is vulnerable to a number of attacks, ranging from exploiting verifivation weaknesses to fault injection, timing attacks, and more
- trusted execution environent (TEE) OS and trusted applcaitions
	- TEE is common in phones and tablets based on systems such as Android.
		- the idea is to create a virtual secure SoC bu paritioning an entire SoC into secure and nnonsecure worlds
		- the goal is to keep all nonsecure and complex opeerations, such as user applcaitions, in the nonsecure world, and all secure operations, such as banking applciation in the secure world
- firmware images
	- firmware is the low-level software that runs on CPUs or peripherals
	- simplle peripherals in a device are often fully hardware based, but more complex peripherials can contain a microcontroller that runs firm ware
- main operating system kernal and appliations
	- the main OS in an embedded system can be a gemeral-purpose OS, like Linux, or a real-time OS, like VxWorks or FreeRTOS.
	
========
### tools
- nmap -p- 10.10.10.142
  - nc -vv 10.10.10.142 8091
    - JSON-RPC
    - curl -X POST --data '{"xyz"}' httpss://10.10.10.142:9810
  - curl httpss://10.10.10.142:9810
- nmap 10.10.10.142
  - Availiable ports
  - ftp 10.10.10.142
    - ftp> get anonymous.txt
  - nc -vz -u 10.10.10.142 30301
- tcpdump -X
- ifconfig
- :set paste
- otool
- xxd
- lldb
- g++ -Os
- g++ -O2










